import { hexOrBufferToBuffer, hexOrBufferToHex, numberToBuffer, reverseBuffer } from "./Utils.js";
import { getBlockStats, getRawBlockHeader, getTransactionDetails } from "./BitcoinRpcClient.js";
import { getStxBlockHeight } from "./BlockApiClient.js";
import { MerkleTree } from "merkletreejs";
import { bufferCV, listCV, tupleCV, uintCV } from "@stacks/transactions";
import SHA256 from "crypto-js/sha256.js";
import { Transaction } from "bitcoinjs-lib";
const SEGWIT_MARKER_OFFSET = 4;
const SEGWIT_FLAG_OFFSET = 5;
export default class ProvableTx {
    tx;
    txId;
    txIndex;
    stxBlockHeight;
    blockHeader;
    proof;
    txDetail;
    blockDetail;
    constructor(tx, txId, txIndex, stxBlockHeight, blockHeader, proof, txDetail, blockDetail) {
        this.tx = tx;
        this.txId = txId;
        this.txIndex = txIndex;
        this.stxBlockHeight = stxBlockHeight;
        this.blockHeader = blockHeader;
        this.proof = proof;
        this.txDetail = txDetail;
        this.blockDetail = blockDetail;
    }
    // TODO There is some kind of race condition or buffer overrun happening when this function gets called more than once
    static async fromTxId(txId) {
        const txIdHex = hexOrBufferToHex(txId);
        const txDetail = await getTransactionDetails(txIdHex);
        const tx = Buffer.from(txDetail.hex, 'hex');
        let txWithoutSegwit;
        const isSegwit = tx.readInt8(SEGWIT_MARKER_OFFSET) === 0;
        const segwitFlag = isSegwit ? tx.readInt8(SEGWIT_FLAG_OFFSET) : 0;
        if (isSegwit && segwitFlag === 1) {
            txWithoutSegwit = Transaction.fromHex(txDetail.hex)
                .toBuffer(undefined, undefined, false); // TODO This requires a hacked bitcoinjs-lib
        }
        const blockHeader = Buffer.from(await getRawBlockHeader(txDetail.blockhash), 'hex');
        const blockDetail = await getBlockStats(txDetail.blockhash);
        const stxBlockHeight = await getStxBlockHeight(blockDetail.height);
        const txIndex = blockDetail.tx.findIndex((id) => id === txId);
        const tree = new MerkleTree(blockDetail.tx, SHA256, { isBitcoinTree: true });
        const proof = tree.getProof(blockDetail.tx, txIndex).map(p => p.data);
        return new ProvableTx(txWithoutSegwit || tx, hexOrBufferToBuffer(txId), txIndex, stxBlockHeight, blockHeader, proof, txDetail, blockDetail);
    }
    toCompactProofCV() {
        return {
            compactHeader: this.getCompactHeaderCV(),
            tx: bufferCV(this.tx),
            proof: this.getProofCV(),
        };
    }
    toProofCV() {
        return {
            header: this.getHeaderCV(),
            tx: bufferCV(this.tx),
            proof: this.getProofCV()
        };
    }
    getHeaderCV() {
        return tupleCV({
            version: bufferCV(reverseBuffer(Buffer.from(this.blockDetail.versionHex, 'hex'))),
            parent: bufferCV(reverseBuffer(Buffer.from(this.blockDetail.previousblockhash, 'hex'))),
            'merkle-root': bufferCV(reverseBuffer(Buffer.from(this.blockDetail.merkleroot, 'hex'))),
            timestamp: bufferCV(numberToBuffer(this.blockDetail.time, 4)),
            nbits: bufferCV(reverseBuffer(Buffer.from(this.blockDetail.bits, 'hex'))),
            nonce: bufferCV(numberToBuffer(this.blockDetail.nonce, 4)),
            height: uintCV(this.stxBlockHeight)
        });
    }
    getProofCV() {
        return tupleCV({
            "tx-index": uintCV(this.txIndex),
            hashes: listCV(this.proof.map(p => bufferCV(reverseBuffer(p)))),
            "tree-depth": uintCV(this.proof.length)
        });
    }
    getCompactHeaderCV() {
        return tupleCV({
            header: bufferCV(this.blockHeader),
            height: uintCV(this.stxBlockHeight)
        });
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJvdmFibGVUeC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL2xpYi9Qcm92YWJsZVR4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBQyxtQkFBbUIsRUFBRSxnQkFBZ0IsRUFBRSxjQUFjLEVBQUUsYUFBYSxFQUFDLE1BQU0sWUFBWSxDQUFBO0FBQy9GLE9BQU8sRUFBQyxhQUFhLEVBQUUsaUJBQWlCLEVBQUUscUJBQXFCLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQTtBQUM3RixPQUFPLEVBQUMsaUJBQWlCLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQTtBQUNyRCxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sY0FBYyxDQUFBO0FBQ3ZDLE9BQU8sRUFBVyxRQUFRLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQTtBQUNoRixPQUFPLE1BQU0sTUFBTSxxQkFBcUIsQ0FBQTtBQUN4QyxPQUFPLEVBQUMsV0FBVyxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBRTFDLE1BQU0sb0JBQW9CLEdBQUcsQ0FBQyxDQUFBO0FBQzlCLE1BQU0sa0JBQWtCLEdBQUcsQ0FBQyxDQUFDO0FBRTdCLE1BQU0sQ0FBQyxPQUFPLE9BQU8sVUFBVTtJQUNWLEVBQUUsQ0FBUTtJQUNWLElBQUksQ0FBUTtJQUNaLE9BQU8sQ0FBUTtJQUNmLGNBQWMsQ0FBUTtJQUN0QixXQUFXLENBQVE7SUFDbkIsS0FBSyxDQUFVO0lBQ2YsUUFBUSxDQUFLO0lBQ2IsV0FBVyxDQUFLO0lBRWpDLFlBQW9CLEVBQVUsRUFBRSxJQUFZLEVBQUUsT0FBZSxFQUFFLGNBQXNCLEVBQUUsV0FBbUIsRUFDOUYsS0FBZSxFQUFFLFFBQWEsRUFBRSxXQUFnQjtRQUN4RCxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQTtRQUNaLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFBO1FBQ2hCLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFB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QUUsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDO1NBQzFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFTyxrQkFBa0I7UUFDdEIsT0FBTyxPQUFPLENBQUM7WUFDWCxNQUFNLEVBQUUsUUFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUM7WUFDbEMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDO1NBQ3RDLENBQUMsQ0FBQztJQUNQLENBQUM7Q0FDSiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7aGV4T3JCdWZmZXJUb0J1ZmZlciwgaGV4T3JCdWZmZXJUb0hleCwgbnVtYmVyVG9CdWZmZXIsIHJldmVyc2VCdWZmZXJ9IGZyb20gXCIuL1V0aWxzLmpzXCJcbmltcG9ydCB7Z2V0QmxvY2tTdGF0cywgZ2V0UmF3QmxvY2tIZWFkZXIsIGdldFRyYW5zYWN0aW9uRGV0YWlsc30gZnJvbSBcIi4vQml0Y29pblJwY0NsaWVudC5qc1wiXG5pbXBvcnQge2dldFN0eEJsb2NrSGVpZ2h0fSBmcm9tIFwiLi9CbG9ja0FwaUNsaWVudC5qc1wiXG5pbXBvcnQge01lcmtsZVRyZWV9IGZyb20gXCJtZXJrbGV0cmVlanNcIlxuaW1wb3J0IHtCdWZmZXJDViwgYnVmZmVyQ1YsIGxpc3RDViwgdHVwbGVDViwgdWludENWfSBmcm9tIFwiQHN0YWNrcy90cmFuc2FjdGlvbnNcIlxuaW1wb3J0IFNIQTI1NiBmcm9tIFwiY3J5cHRvLWpzL3NoYTI1Ni5qc1wiXG5pbXBvcnQge1RyYW5zYWN0aW9ufSBmcm9tIFwiYml0Y29pbmpzLWxpYlwiO1xuXG5jb25zdCBTRUdXSVRfTUFSS0VSX09GRlNFVCA9IDRcbmNvbnN0IFNFR1dJVF9GTEFHX09GRlNFVCA9IDU7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb3ZhYmxlVHgge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgdHg6IEJ1ZmZlclxuICAgIHByaXZhdGUgcmVhZG9ubHkgdHhJZDogQnVmZmVyXG4gICAgcHJpdmF0ZSByZWFkb25seSB0eEluZGV4OiBudW1iZXJcbiAgICBwcml2YXRlIHJlYWRvbmx5IHN0eEJsb2NrSGVpZ2h0OiBudW1iZXJcbiAgICBwcml2YXRlIHJlYWRvbmx5IGJsb2NrSGVhZGVyOiBCdWZmZXJcbiAgICBwcml2YXRlIHJlYWRvbmx5IHByb29mOiBCdWZmZXJbXVxuICAgIHByaXZhdGUgcmVhZG9ubHkgdHhEZXRhaWw6IGFueVxuICAgIHByaXZhdGUgcmVhZG9ubHkgYmxvY2tEZXRhaWw6IGFueVxuXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcih0eDogQnVmZmVyLCB0eElkOiBCdWZmZXIsIHR4SW5kZXg6IG51bWJlciwgc3R4QmxvY2tIZWlnaHQ6IG51bWJlciwgYmxvY2tIZWFkZXI6IEJ1ZmZlcixcbiAgICAgICAgICAgICAgICBwcm9vZjogQnVmZmVyW10sIHR4RGV0YWlsOiBhbnksIGJsb2NrRGV0YWlsOiBhbnkpIHtcbiAgICAgICAgdGhpcy50eCA9IHR4XG4gICAgICAgIHRoaXMudHhJZCA9IHR4SWRcbiAgICAgICAgdGhpcy50eEluZGV4ID0gdHhJbmRleFxuICAgICAgICB0aGlzLnN0eEJsb2NrSGVpZ2h0ID0gc3R4QmxvY2tIZWlnaHRcbiAgICAgICAgdGhpcy5ibG9ja0hlYWRlciA9IGJsb2NrSGVhZGVyXG4gICAgICAgIHRoaXMucHJvb2YgPSBwcm9vZlxuICAgICAgICB0aGlzLnR4RGV0YWlsID0gdHhEZXRhaWxcbiAgICAgICAgdGhpcy5ibG9ja0RldGFpbCA9IGJsb2NrRGV0YWlsXG4gICAgfVxuXG4gICAgLy8gVE9ETyBUaGVyZSBpcyBzb21lIGtpbmQgb2YgcmFjZSBjb25kaXRpb24gb3IgYnVmZmVyIG92ZXJydW4gaGFwcGVuaW5nIHdoZW4gdGhpcyBmdW5jdGlvbiBnZXRzIGNhbGxlZCBtb3JlIHRoYW4gb25jZVxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgZnJvbVR4SWQodHhJZDogc3RyaW5nIHwgQnVmZmVyKTogUHJvbWlzZTxQcm92YWJsZVR4PiB7XG4gICAgICAgIGNvbnN0IHR4SWRIZXggPSBoZXhPckJ1ZmZlclRvSGV4KHR4SWQpXG4gICAgICAgIGNvbnN0IHR4RGV0YWlsID0gYXdhaXQgZ2V0VHJhbnNhY3Rpb25EZXRhaWxzKHR4SWRIZXgpXG4gICAgICAgIGNvbnN0IHR4ID0gQnVmZmVyLmZyb20odHhEZXRhaWwuaGV4LCAnaGV4JylcbiAgICAgICAgbGV0IHR4V2l0aG91dFNlZ3dpdFxuXG4gICAgICAgIGNvbnN0IGlzU2Vnd2l0ID0gdHgucmVhZEludDgoU0VHV0lUX01BUktFUl9PRkZTRVQpID09PSAwXG4gICAgICAgIGNvbnN0IHNlZ3dpdEZsYWcgPSBpc1NlZ3dpdCA/IHR4LnJlYWRJbnQ4KFNFR1dJVF9GTEFHX09GRlNFVCkgOiAwXG4gICAgICAgIGlmIChpc1NlZ3dpdCAmJiBzZWd3aXRGbGFnID09PSAxKSB7XG4gICAgICAgICAgICB0eFdpdGhvdXRTZWd3aXQgPSBUcmFuc2FjdGlvbi5mcm9tSGV4KHR4RGV0YWlsLmhleClcbiAgICAgICAgICAgICAgICAudG9CdWZmZXIodW5kZWZpbmVkLCB1bmRlZmluZWQsIGZhbHNlKSAvLyBUT0RPIFRoaXMgcmVxdWlyZXMgYSBoYWNrZWQgYml0Y29pbmpzLWxpYlxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYmxvY2tIZWFkZXIgPSBCdWZmZXIuZnJvbShhd2FpdCBnZXRSYXdCbG9ja0hlYWRlcih0eERldGFpbC5ibG9ja2hhc2gpLCAnaGV4JylcbiAgICAgICAgY29uc3QgYmxvY2tEZXRhaWwgPSBhd2FpdCBnZXRCbG9ja1N0YXRzKHR4RGV0YWlsLmJsb2NraGFzaClcbiAgICAgICAgY29uc3Qgc3R4QmxvY2tIZWlnaHQgPSBhd2FpdCBnZXRTdHhCbG9ja0hlaWdodChibG9ja0RldGFpbC5oZWlnaHQpIGFzIG51bWJlclxuICAgICAgICBjb25zdCB0eEluZGV4ID0gYmxvY2tEZXRhaWwudHguZmluZEluZGV4KChpZDogc3RyaW5nKSA9PiBpZCA9PT0gdHhJZClcblxuICAgICAgICBjb25zdCB0cmVlID0gbmV3IE1lcmtsZVRyZWUoYmxvY2tEZXRhaWwudHgsIFNIQTI1Niwge2lzQml0Y29pblRyZWU6IHRydWV9KVxuICAgICAgICBjb25zdCBwcm9vZiA9IHRyZWUuZ2V0UHJvb2YoYmxvY2tEZXRhaWwudHgsIHR4SW5kZXgpLm1hcChwID0+IHAuZGF0YSlcbiAgICAgICAgcmV0dXJuIG5ldyBQcm92YWJsZVR4KFxuICAgICAgICAgICAgdHhXaXRob3V0U2Vnd2l0IHx8IHR4LFxuICAgICAgICAgICAgaGV4T3JCdWZmZXJUb0J1ZmZlcih0eElkKSxcbiAgICAgICAgICAgIHR4SW5kZXgsXG4gICAgICAgICAgICBzdHhCbG9ja0hlaWdodCxcbiAgICAgICAgICAgIGJsb2NrSGVhZGVyLFxuICAgICAgICAgICAgcHJvb2YsXG4gICAgICAgICAgICB0eERldGFpbCxcbiAgICAgICAgICAgIGJsb2NrRGV0YWlsXG4gICAgICAgIClcbiAgICB9XG5cbiAgICB0b0NvbXBhY3RQcm9vZkNWKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29tcGFjdEhlYWRlcjogdGhpcy5nZXRDb21wYWN0SGVhZGVyQ1YoKSxcbiAgICAgICAgICAgIHR4OiBidWZmZXJDVih0aGlzLnR4KSxcbiAgICAgICAgICAgIHByb29mOiB0aGlzLmdldFByb29mQ1YoKSxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvUHJvb2ZDVigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlYWRlcjogdGhpcy5nZXRIZWFkZXJDVigpLFxuICAgICAgICAgICAgdHg6IGJ1ZmZlckNWKHRoaXMudHgpLFxuICAgICAgICAgICAgcHJvb2Y6IHRoaXMuZ2V0UHJvb2ZDVigpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEhlYWRlckNWKCkge1xuICAgICAgICByZXR1cm4gdHVwbGVDVih7XG4gICAgICAgICAgICB2ZXJzaW9uOiBidWZmZXJDVihyZXZlcnNlQnVmZmVyKEJ1ZmZlci5mcm9tKHRoaXMuYmxvY2tEZXRhaWwudmVyc2lvbkhleCwgJ2hleCcpKSksXG4gICAgICAgICAgICBwYXJlbnQ6IGJ1ZmZlckNWKHJldmVyc2VCdWZmZXIoQnVmZmVyLmZyb20odGhpcy5ibG9ja0RldGFpbC5wcmV2aW91c2Jsb2NraGFzaCwgJ2hleCcpKSksXG4gICAgICAgICAgICAnbWVya2xlLXJvb3QnOiBidWZmZXJDVihyZXZlcnNlQnVmZmVyKEJ1ZmZlci5mcm9tKHRoaXMuYmxvY2tEZXRhaWwubWVya2xlcm9vdCwgJ2hleCcpKSksXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGJ1ZmZlckNWKG51bWJlclRvQnVmZmVyKHRoaXMuYmxvY2tEZXRhaWwudGltZSwgNCkpLFxuICAgICAgICAgICAgbmJpdHM6IGJ1ZmZlckNWKHJldmVyc2VCdWZmZXIoQnVmZmVyLmZyb20odGhpcy5ibG9ja0RldGFpbC5iaXRzLCAnaGV4JykpKSxcbiAgICAgICAgICAgIG5vbmNlOiBidWZmZXJDVihudW1iZXJUb0J1ZmZlcih0aGlzLmJsb2NrRGV0YWlsLm5vbmNlLCA0KSksXG4gICAgICAgICAgICBoZWlnaHQ6IHVpbnRDVih0aGlzLnN0eEJsb2NrSGVpZ2h0KVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFByb29mQ1YoKSB7XG4gICAgICAgIHJldHVybiB0dXBsZUNWKHtcbiAgICAgICAgICAgIFwidHgtaW5kZXhcIjogdWludENWKHRoaXMudHhJbmRleCksXG4gICAgICAgICAgICBoYXNoZXM6IGxpc3RDVjxCdWZmZXJDVj4odGhpcy5wcm9vZi5tYXAocCA9PiBidWZmZXJDVihyZXZlcnNlQnVmZmVyKHApKSkpLFxuICAgICAgICAgICAgXCJ0cmVlLWRlcHRoXCI6IHVpbnRDVih0aGlzLnByb29mLmxlbmd0aClcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRDb21wYWN0SGVhZGVyQ1YoKSB7XG4gICAgICAgIHJldHVybiB0dXBsZUNWKHtcbiAgICAgICAgICAgIGhlYWRlcjogYnVmZmVyQ1YodGhpcy5ibG9ja0hlYWRlciksXG4gICAgICAgICAgICBoZWlnaHQ6IHVpbnRDVih0aGlzLnN0eEJsb2NrSGVpZ2h0KVxuICAgICAgICB9KTtcbiAgICB9XG59XG4iXX0=
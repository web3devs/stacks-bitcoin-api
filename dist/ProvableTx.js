import { hexOrBufferToBuffer, hexOrBufferToHex, numberToBufferLE, reverseBuffer } from './Utils.js';
import { getBlockStats, getRawBlockHeader, getTransactionDetails } from './BitcoinRpcClient.js';
import { getStxBlockHeight } from './BlockApiClient.js';
import { MerkleTree } from 'merkletreejs';
import { bufferCV, listCV, tupleCV, uintCV } from '@stacks/transactions';
import SHA256 from 'crypto-js/sha256.js';
import { Transaction } from 'bitcoinjs-lib';
const SEGWIT_MARKER_OFFSET = 4;
const SEGWIT_FLAG_OFFSET = 5;
export default class ProvableTx {
    tx;
    txId;
    txIndex;
    stxBlockHeight;
    blockHeader;
    proof;
    txDetail;
    blockDetail;
    constructor(tx, txId, txIndex, stxBlockHeight, blockHeader, proof, txDetail, blockDetail) {
        this.tx = tx;
        this.txId = txId;
        this.txIndex = txIndex;
        this.stxBlockHeight = stxBlockHeight;
        this.blockHeader = blockHeader;
        this.proof = proof;
        this.txDetail = txDetail;
        this.blockDetail = blockDetail;
    }
    static async fromTxId(txId) {
        const txIdHex = hexOrBufferToHex(txId);
        const txDetail = await getTransactionDetails(txIdHex);
        const tx = Buffer.from(txDetail.hex, 'hex');
        let txWithoutSegwit;
        const isSegwit = tx.readInt8(SEGWIT_MARKER_OFFSET) === 0;
        const segwitFlag = isSegwit ? tx.readInt8(SEGWIT_FLAG_OFFSET) : 0;
        if (isSegwit) {
            if (segwitFlag === 1) {
                // NOTE This requires a hacked bitcoinjs-lib
                txWithoutSegwit = Transaction.fromHex(txDetail.hex).toBuffer(undefined, undefined, false);
            }
            else {
                throw 'unknown segwit flag value';
            }
        }
        const blockHeader = Buffer.from(await getRawBlockHeader(txDetail.blockhash), 'hex');
        const blockDetail = await getBlockStats(txDetail.blockhash);
        const stxBlockHeight = (await getStxBlockHeight(blockDetail.height));
        const txIndex = blockDetail.tx.findIndex((id) => id === txId);
        const tree = new MerkleTree(blockDetail.tx, SHA256, {
            isBitcoinTree: true,
        });
        const proof = tree.getProof(blockDetail.tx, txIndex).map((p) => p.data);
        return new ProvableTx(txWithoutSegwit || tx, hexOrBufferToBuffer(txId), txIndex, stxBlockHeight, blockHeader, proof, txDetail, blockDetail);
    }
    toCompactProofCV() {
        return {
            compactHeader: this.getCompactHeaderCV(),
            tx: bufferCV(this.tx),
            proof: this.getProofCV(),
        };
    }
    toProofCV() {
        return {
            header: this.getHeaderCV(),
            tx: bufferCV(this.tx),
            proof: this.getProofCV(),
        };
    }
    getHeaderCV() {
        return tupleCV({
            version: bufferCV(reverseBuffer(Buffer.from(this.blockDetail.versionHex, 'hex'))),
            parent: bufferCV(reverseBuffer(Buffer.from(this.blockDetail.previousblockhash, 'hex'))),
            'merkle-root': bufferCV(reverseBuffer(Buffer.from(this.blockDetail.merkleroot, 'hex'))),
            timestamp: bufferCV(numberToBufferLE(this.blockDetail.time, 4)),
            nbits: bufferCV(reverseBuffer(Buffer.from(this.blockDetail.bits, 'hex'))),
            nonce: bufferCV(numberToBufferLE(this.blockDetail.nonce, 4)),
            height: uintCV(this.stxBlockHeight),
        });
    }
    getProofCV() {
        return tupleCV({
            'tx-index': uintCV(this.txIndex),
            hashes: listCV(this.proof.map((p) => bufferCV(reverseBuffer(Buffer.from(p))))),
            'tree-depth': uintCV(this.proof.length),
        });
    }
    getCompactHeaderCV() {
        return tupleCV({
            header: bufferCV(Buffer.from(this.blockHeader)),
            height: uintCV(this.stxBlockHeight),
        });
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJvdmFibGVUeC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL2xpYi9Qcm92YWJsZVR4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxnQkFBZ0IsRUFBRSxnQkFBZ0IsRUFBRSxhQUFhLEVBQUUsTUFBTSxZQUFZLENBQUE7QUFDbkcsT0FBTyxFQUFFLGFBQWEsRUFBRSxpQkFBaUIsRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHVCQUF1QixDQUFBO0FBQy9GLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHFCQUFxQixDQUFBO0FBQ3ZELE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxjQUFjLENBQUE7QUFDekMsT0FBTyxFQUFZLFFBQVEsRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLHNCQUFzQixDQUFBO0FBQ2xGLE9BQU8sTUFBTSxNQUFNLHFCQUFxQixDQUFBO0FBQ3hDLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxlQUFlLENBQUE7QUFFM0MsTUFBTSxvQkFBb0IsR0FBRyxDQUFDLENBQUE7QUFDOUIsTUFBTSxrQkFBa0IsR0FBRyxDQUFDLENBQUE7QUFFNUIsTUFBTSxDQUFDLE9BQU8sT0FBTyxVQUFVO0lBQ2xCLEVBQUUsQ0FBUTtJQUNWLElBQUksQ0FBUTtJQUNaLE9BQU8sQ0FBUTtJQUNmLGNBQWMsQ0FBUTtJQUN0QixXQUFXLENBQVE7SUFDbkIsS0FBSyxDQUFVO0lBQ2YsUUFBUSxDQUFLO0lBQ2IsV0FBVyxDQUFLO0lBRXpCLFlBQ0ksRUFBVSxFQUNWLElBQVksRUFDWixPQUFlLEVBQ2YsY0FBc0IsRUFDdEIsV0FBbUIsRUFDbkIsS0FBZSxFQUNmLFFBQWEsRUFDYixXQUFnQjtRQUVoQixJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQTtRQUNaLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFBO1FBQ2hCLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxD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QUUsQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDeEYsWUFBWSxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQztTQUMxQyxDQUFDLENBQUE7SUFDTixDQUFDO0lBRU8sa0JBQWtCO1FBQ3RCLE9BQU8sT0FBTyxDQUFDO1lBQ1gsTUFBTSxFQUFFLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUMvQyxNQUFNLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUM7U0FDdEMsQ0FBQyxDQUFBO0lBQ04sQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaGV4T3JCdWZmZXJUb0J1ZmZlciwgaGV4T3JCdWZmZXJUb0hleCwgbnVtYmVyVG9CdWZmZXJMRSwgcmV2ZXJzZUJ1ZmZlciB9IGZyb20gJy4vVXRpbHMuanMnXG5pbXBvcnQgeyBnZXRCbG9ja1N0YXRzLCBnZXRSYXdCbG9ja0hlYWRlciwgZ2V0VHJhbnNhY3Rpb25EZXRhaWxzIH0gZnJvbSAnLi9CaXRjb2luUnBjQ2xpZW50LmpzJ1xuaW1wb3J0IHsgZ2V0U3R4QmxvY2tIZWlnaHQgfSBmcm9tICcuL0Jsb2NrQXBpQ2xpZW50LmpzJ1xuaW1wb3J0IHsgTWVya2xlVHJlZSB9IGZyb20gJ21lcmtsZXRyZWVqcydcbmltcG9ydCB7IEJ1ZmZlckNWLCBidWZmZXJDViwgbGlzdENWLCB0dXBsZUNWLCB1aW50Q1YgfSBmcm9tICdAc3RhY2tzL3RyYW5zYWN0aW9ucydcbmltcG9ydCBTSEEyNTYgZnJvbSAnY3J5cHRvLWpzL3NoYTI1Ni5qcydcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnYml0Y29pbmpzLWxpYidcblxuY29uc3QgU0VHV0lUX01BUktFUl9PRkZTRVQgPSA0XG5jb25zdCBTRUdXSVRfRkxBR19PRkZTRVQgPSA1XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb3ZhYmxlVHgge1xuICAgIHJlYWRvbmx5IHR4OiBCdWZmZXJcbiAgICByZWFkb25seSB0eElkOiBCdWZmZXJcbiAgICByZWFkb25seSB0eEluZGV4OiBudW1iZXJcbiAgICByZWFkb25seSBzdHhCbG9ja0hlaWdodDogbnVtYmVyXG4gICAgcmVhZG9ubHkgYmxvY2tIZWFkZXI6IEJ1ZmZlclxuICAgIHJlYWRvbmx5IHByb29mOiBCdWZmZXJbXVxuICAgIHJlYWRvbmx5IHR4RGV0YWlsOiBhbnlcbiAgICByZWFkb25seSBibG9ja0RldGFpbDogYW55XG5cbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKFxuICAgICAgICB0eDogQnVmZmVyLFxuICAgICAgICB0eElkOiBCdWZmZXIsXG4gICAgICAgIHR4SW5kZXg6IG51bWJlcixcbiAgICAgICAgc3R4QmxvY2tIZWlnaHQ6IG51bWJlcixcbiAgICAgICAgYmxvY2tIZWFkZXI6IEJ1ZmZlcixcbiAgICAgICAgcHJvb2Y6IEJ1ZmZlcltdLFxuICAgICAgICB0eERldGFpbDogYW55LFxuICAgICAgICBibG9ja0RldGFpbDogYW55XG4gICAgKSB7XG4gICAgICAgIHRoaXMudHggPSB0eFxuICAgICAgICB0aGlzLnR4SWQgPSB0eElkXG4gICAgICAgIHRoaXMudHhJbmRleCA9IHR4SW5kZXhcbiAgICAgICAgdGhpcy5zdHhCbG9ja0hlaWdodCA9IHN0eEJsb2NrSGVpZ2h0XG4gICAgICAgIHRoaXMuYmxvY2tIZWFkZXIgPSBibG9ja0hlYWRlclxuICAgICAgICB0aGlzLnByb29mID0gcHJvb2ZcbiAgICAgICAgdGhpcy50eERldGFpbCA9IHR4RGV0YWlsXG4gICAgICAgIHRoaXMuYmxvY2tEZXRhaWwgPSBibG9ja0RldGFpbFxuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgZnJvbVR4SWQodHhJZDogc3RyaW5nIHwgQnVmZmVyKTogUHJvbWlzZTxQcm92YWJsZVR4PiB7XG4gICAgICAgIGNvbnN0IHR4SWRIZXggPSBoZXhPckJ1ZmZlclRvSGV4KHR4SWQpXG4gICAgICAgIGNvbnN0IHR4RGV0YWlsID0gYXdhaXQgZ2V0VHJhbnNhY3Rpb25EZXRhaWxzKHR4SWRIZXgpXG4gICAgICAgIGNvbnN0IHR4ID0gQnVmZmVyLmZyb20odHhEZXRhaWwuaGV4LCAnaGV4JylcbiAgICAgICAgbGV0IHR4V2l0aG91dFNlZ3dpdFxuXG4gICAgICAgIGNvbnN0IGlzU2Vnd2l0ID0gdHgucmVhZEludDgoU0VHV0lUX01BUktFUl9PRkZTRVQpID09PSAwXG4gICAgICAgIGNvbnN0IHNlZ3dpdEZsYWcgPSBpc1NlZ3dpdCA/IHR4LnJlYWRJbnQ4KFNFR1dJVF9GTEFHX09GRlNFVCkgOiAwXG4gICAgICAgIGlmIChpc1NlZ3dpdCkge1xuICAgICAgICAgICAgaWYgKHNlZ3dpdEZsYWcgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBOT1RFIFRoaXMgcmVxdWlyZXMgYSBoYWNrZWQgYml0Y29pbmpzLWxpYlxuICAgICAgICAgICAgICAgIHR4V2l0aG91dFNlZ3dpdCA9IFRyYW5zYWN0aW9uLmZyb21IZXgodHhEZXRhaWwuaGV4KS50b0J1ZmZlcih1bmRlZmluZWQsIHVuZGVmaW5lZCwgZmFsc2UpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93ICd1bmtub3duIHNlZ3dpdCBmbGFnIHZhbHVlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYmxvY2tIZWFkZXIgPSBCdWZmZXIuZnJvbShhd2FpdCBnZXRSYXdCbG9ja0hlYWRlcih0eERldGFpbC5ibG9ja2hhc2gpLCAnaGV4JylcbiAgICAgICAgY29uc3QgYmxvY2tEZXRhaWwgPSBhd2FpdCBnZXRCbG9ja1N0YXRzKHR4RGV0YWlsLmJsb2NraGFzaClcbiAgICAgICAgY29uc3Qgc3R4QmxvY2tIZWlnaHQgPSAoYXdhaXQgZ2V0U3R4QmxvY2tIZWlnaHQoYmxvY2tEZXRhaWwuaGVpZ2h0KSkgYXMgbnVtYmVyXG4gICAgICAgIGNvbnN0IHR4SW5kZXggPSBibG9ja0RldGFpbC50eC5maW5kSW5kZXgoKGlkOiBzdHJpbmcpID0+IGlkID09PSB0eElkKVxuXG4gICAgICAgIGNvbnN0IHRyZWUgPSBuZXcgTWVya2xlVHJlZShibG9ja0RldGFpbC50eCwgU0hBMjU2LCB7XG4gICAgICAgICAgICBpc0JpdGNvaW5UcmVlOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgICBjb25zdCBwcm9vZiA9IHRyZWUuZ2V0UHJvb2YoYmxvY2tEZXRhaWwudHgsIHR4SW5kZXgpLm1hcCgocCkgPT4gcC5kYXRhKVxuICAgICAgICByZXR1cm4gbmV3IFByb3ZhYmxlVHgoXG4gICAgICAgICAgICB0eFdpdGhvdXRTZWd3aXQgfHwgdHgsXG4gICAgICAgICAgICBoZXhPckJ1ZmZlclRvQnVmZmVyKHR4SWQpLFxuICAgICAgICAgICAgdHhJbmRleCxcbiAgICAgICAgICAgIHN0eEJsb2NrSGVpZ2h0LFxuICAgICAgICAgICAgYmxvY2tIZWFkZXIsXG4gICAgICAgICAgICBwcm9vZixcbiAgICAgICAgICAgIHR4RGV0YWlsLFxuICAgICAgICAgICAgYmxvY2tEZXRhaWxcbiAgICAgICAgKVxuICAgIH1cblxuICAgIHRvQ29tcGFjdFByb29mQ1YoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb21wYWN0SGVhZGVyOiB0aGlzLmdldENvbXBhY3RIZWFkZXJDVigpLFxuICAgICAgICAgICAgdHg6IGJ1ZmZlckNWKHRoaXMudHgpLFxuICAgICAgICAgICAgcHJvb2Y6IHRoaXMuZ2V0UHJvb2ZDVigpLFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9Qcm9vZkNWKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVhZGVyOiB0aGlzLmdldEhlYWRlckNWKCksXG4gICAgICAgICAgICB0eDogYnVmZmVyQ1YodGhpcy50eCksXG4gICAgICAgICAgICBwcm9vZjogdGhpcy5nZXRQcm9vZkNWKCksXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEhlYWRlckNWKCkge1xuICAgICAgICByZXR1cm4gdHVwbGVDVih7XG4gICAgICAgICAgICB2ZXJzaW9uOiBidWZmZXJDVihyZXZlcnNlQnVmZmVyKEJ1ZmZlci5mcm9tKHRoaXMuYmxvY2tEZXRhaWwudmVyc2lvbkhleCwgJ2hleCcpKSksXG4gICAgICAgICAgICBwYXJlbnQ6IGJ1ZmZlckNWKHJldmVyc2VCdWZmZXIoQnVmZmVyLmZyb20odGhpcy5ibG9ja0RldGFpbC5wcmV2aW91c2Jsb2NraGFzaCwgJ2hleCcpKSksXG4gICAgICAgICAgICAnbWVya2xlLXJvb3QnOiBidWZmZXJDVihyZXZlcnNlQnVmZmVyKEJ1ZmZlci5mcm9tKHRoaXMuYmxvY2tEZXRhaWwubWVya2xlcm9vdCwgJ2hleCcpKSksXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGJ1ZmZlckNWKG51bWJlclRvQnVmZmVyTEUodGhpcy5ibG9ja0RldGFpbC50aW1lLCA0KSksXG4gICAgICAgICAgICBuYml0czogYnVmZmVyQ1YocmV2ZXJzZUJ1ZmZlcihCdWZmZXIuZnJvbSh0aGlzLmJsb2NrRGV0YWlsLmJpdHMsICdoZXgnKSkpLFxuICAgICAgICAgICAgbm9uY2U6IGJ1ZmZlckNWKG51bWJlclRvQnVmZmVyTEUodGhpcy5ibG9ja0RldGFpbC5ub25jZSwgNCkpLFxuICAgICAgICAgICAgaGVpZ2h0OiB1aW50Q1YodGhpcy5zdHhCbG9ja0hlaWdodCksXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRQcm9vZkNWKCkge1xuICAgICAgICByZXR1cm4gdHVwbGVDVih7XG4gICAgICAgICAgICAndHgtaW5kZXgnOiB1aW50Q1YodGhpcy50eEluZGV4KSxcbiAgICAgICAgICAgIGhhc2hlczogbGlzdENWPEJ1ZmZlckNWPih0aGlzLnByb29mLm1hcCgocCkgPT4gYnVmZmVyQ1YocmV2ZXJzZUJ1ZmZlcihCdWZmZXIuZnJvbShwKSkpKSksXG4gICAgICAgICAgICAndHJlZS1kZXB0aCc6IHVpbnRDVih0aGlzLnByb29mLmxlbmd0aCksXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRDb21wYWN0SGVhZGVyQ1YoKSB7XG4gICAgICAgIHJldHVybiB0dXBsZUNWKHtcbiAgICAgICAgICAgIGhlYWRlcjogYnVmZmVyQ1YoQnVmZmVyLmZyb20odGhpcy5ibG9ja0hlYWRlcikpLFxuICAgICAgICAgICAgaGVpZ2h0OiB1aW50Q1YodGhpcy5zdHhCbG9ja0hlaWdodCksXG4gICAgICAgIH0pXG4gICAgfVxufVxuIl19
import { hexOrBufferToBuffer, hexOrBufferToHex, numberToBuffer, reverseBuffer } from "./Utils.js";
import { getBlockStats, getRawBlockHeader, getTransactionDetails } from "./BitcoinRpcClient.js";
import { getStxBlockHeight } from "./BlockApiClient.js";
import { MerkleTree } from "merkletreejs";
import { bufferCV, listCV, tupleCV, uintCV } from "@stacks/transactions";
import SHA256 from "crypto-js/sha256.js";
import { Transaction } from "bitcoinjs-lib";
const SEGWIT_MARKER_OFFSET = 4;
const SEGWIT_FLAG_OFFSET = 5;
export default class ProvableTx {
    tx;
    txId;
    txIndex;
    stxBlockHeight;
    blockHeader;
    proof;
    txDetail;
    blockDetail;
    constructor(tx, txId, txIndex, stxBlockHeight, blockHeader, proof, txDetail, blockDetail) {
        this.tx = tx;
        this.txId = txId;
        this.txIndex = txIndex;
        this.stxBlockHeight = stxBlockHeight;
        this.blockHeader = blockHeader;
        this.proof = proof;
        this.txDetail = txDetail;
        this.blockDetail = blockDetail;
    }
    // TODO There is some kind of race condition or buffer overrun happening when this function gets called more than once
    static async fromTxId(txId) {
        const txIdHex = hexOrBufferToHex(txId);
        const txDetail = await getTransactionDetails(txIdHex);
        const tx = Buffer.from(txDetail.hex, 'hex');
        let txWithoutSegwit;
        const isSegwit = tx.readInt8(SEGWIT_MARKER_OFFSET) === 0;
        const segwitFlag = isSegwit ? tx.readInt8(SEGWIT_FLAG_OFFSET) : 0;
        if (isSegwit) {
            if (segwitFlag === 1) {
                txWithoutSegwit = Transaction.fromHex(txDetail.hex)
                    .toBuffer(undefined, undefined, false); // TODO This requires a hacked bitcoinjs-lib
            }
            else {
                throw "unknown segwit flag value";
            }
        }
        const blockHeader = Buffer.from(await getRawBlockHeader(txDetail.blockhash), 'hex');
        const blockDetail = await getBlockStats(txDetail.blockhash);
        const stxBlockHeight = await getStxBlockHeight(blockDetail.height);
        const txIndex = blockDetail.tx.findIndex((id) => id === txId);
        const tree = new MerkleTree(blockDetail.tx, SHA256, { isBitcoinTree: true });
        const proof = tree.getProof(blockDetail.tx, txIndex).map(p => p.data);
        return new ProvableTx(txWithoutSegwit || tx, hexOrBufferToBuffer(txId), txIndex, stxBlockHeight, blockHeader, proof, txDetail, blockDetail);
    }
    toCompactProofCV() {
        return {
            compactHeader: this.getCompactHeaderCV(),
            tx: bufferCV(this.tx),
            proof: this.getProofCV(),
        };
    }
    toProofCV() {
        return {
            header: this.getHeaderCV(),
            tx: bufferCV(this.tx),
            proof: this.getProofCV()
        };
    }
    getHeaderCV() {
        return tupleCV({
            version: bufferCV(reverseBuffer(Buffer.from(this.blockDetail.versionHex, 'hex'))),
            parent: bufferCV(reverseBuffer(Buffer.from(this.blockDetail.previousblockhash, 'hex'))),
            'merkle-root': bufferCV(reverseBuffer(Buffer.from(this.blockDetail.merkleroot, 'hex'))),
            timestamp: bufferCV(numberToBuffer(this.blockDetail.time, 4)),
            nbits: bufferCV(reverseBuffer(Buffer.from(this.blockDetail.bits, 'hex'))),
            nonce: bufferCV(numberToBuffer(this.blockDetail.nonce, 4)),
            height: uintCV(this.stxBlockHeight)
        });
    }
    getProofCV() {
        return tupleCV({
            "tx-index": uintCV(this.txIndex),
            hashes: listCV(this.proof.map(p => bufferCV(reverseBuffer(p)))),
            "tree-depth": uintCV(this.proof.length)
        });
    }
    getCompactHeaderCV() {
        return tupleCV({
            header: bufferCV(this.blockHeader),
            height: uintCV(this.stxBlockHeight)
        });
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJvdmFibGVUeC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL2xpYi9Qcm92YWJsZVR4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBQyxtQkFBbUIsRUFBRSxnQkFBZ0IsRUFBRSxjQUFjLEVBQUUsYUFBYSxFQUFDLE1BQU0sWUFBWSxDQUFBO0FBQy9GLE9BQU8sRUFBQyxhQUFhLEVBQUUsaUJBQWlCLEVBQUUscUJBQXFCLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQTtBQUM3RixPQUFPLEVBQUMsaUJBQWlCLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQTtBQUNyRCxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sY0FBYyxDQUFBO0FBQ3ZDLE9BQU8sRUFBVyxRQUFRLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQTtBQUNoRixPQUFPLE1BQU0sTUFBTSxxQkFBcUIsQ0FBQTtBQUN4QyxPQUFPLEVBQUMsV0FBVyxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBRTFDLE1BQU0sb0JBQW9CLEdBQUcsQ0FBQyxDQUFBO0FBQzlCLE1BQU0sa0JBQWtCLEdBQUcsQ0FBQyxDQUFDO0FBRTdCLE1BQU0sQ0FBQyxPQUFPLE9BQU8sVUFBVTtJQUNWLEVBQUUsQ0FBUTtJQUNWLElBQUksQ0FBUTtJQUNaLE9BQU8sQ0FBUTtJQUNmLGNBQWMsQ0FBUTtJQUN0QixXQUFXLENBQVE7SUFDbkIsS0FBSyxDQUFVO0lBQ2YsUUFBUSxDQUFLO0lBQ2IsV0FBVyxDQUFLO0lBRWpDLFlBQW9CLEVBQVUsRUFBRSxJQUFZLEVBQUUsT0FBZSxFQUFFLGNBQXNCLEVBQUUsV0FBbUIsRUFDOUYsS0FBZSxFQUFFLFFBQWEsRUFBRSxXQUFnQjtRQUN4RCxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQTtRQUNaLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFBO1FBQ2hCLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFB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QUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN6RSxZQUFZLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDO1NBQzFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFTyxrQkFBa0I7UUFDdEIsT0FBTyxPQUFPLENBQUM7WUFDWCxNQUFNLEVBQUUsUUFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUM7WUFDbEMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDO1NBQ3RDLENBQUMsQ0FBQztJQUNQLENBQUM7Q0FDSiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7aGV4T3JCdWZmZXJUb0J1ZmZlciwgaGV4T3JCdWZmZXJUb0hleCwgbnVtYmVyVG9CdWZmZXIsIHJldmVyc2VCdWZmZXJ9IGZyb20gXCIuL1V0aWxzLmpzXCJcbmltcG9ydCB7Z2V0QmxvY2tTdGF0cywgZ2V0UmF3QmxvY2tIZWFkZXIsIGdldFRyYW5zYWN0aW9uRGV0YWlsc30gZnJvbSBcIi4vQml0Y29pblJwY0NsaWVudC5qc1wiXG5pbXBvcnQge2dldFN0eEJsb2NrSGVpZ2h0fSBmcm9tIFwiLi9CbG9ja0FwaUNsaWVudC5qc1wiXG5pbXBvcnQge01lcmtsZVRyZWV9IGZyb20gXCJtZXJrbGV0cmVlanNcIlxuaW1wb3J0IHtCdWZmZXJDViwgYnVmZmVyQ1YsIGxpc3RDViwgdHVwbGVDViwgdWludENWfSBmcm9tIFwiQHN0YWNrcy90cmFuc2FjdGlvbnNcIlxuaW1wb3J0IFNIQTI1NiBmcm9tIFwiY3J5cHRvLWpzL3NoYTI1Ni5qc1wiXG5pbXBvcnQge1RyYW5zYWN0aW9ufSBmcm9tIFwiYml0Y29pbmpzLWxpYlwiO1xuXG5jb25zdCBTRUdXSVRfTUFSS0VSX09GRlNFVCA9IDRcbmNvbnN0IFNFR1dJVF9GTEFHX09GRlNFVCA9IDU7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb3ZhYmxlVHgge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgdHg6IEJ1ZmZlclxuICAgIHByaXZhdGUgcmVhZG9ubHkgdHhJZDogQnVmZmVyXG4gICAgcHJpdmF0ZSByZWFkb25seSB0eEluZGV4OiBudW1iZXJcbiAgICBwcml2YXRlIHJlYWRvbmx5IHN0eEJsb2NrSGVpZ2h0OiBudW1iZXJcbiAgICBwcml2YXRlIHJlYWRvbmx5IGJsb2NrSGVhZGVyOiBCdWZmZXJcbiAgICBwcml2YXRlIHJlYWRvbmx5IHByb29mOiBCdWZmZXJbXVxuICAgIHByaXZhdGUgcmVhZG9ubHkgdHhEZXRhaWw6IGFueVxuICAgIHByaXZhdGUgcmVhZG9ubHkgYmxvY2tEZXRhaWw6IGFueVxuXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcih0eDogQnVmZmVyLCB0eElkOiBCdWZmZXIsIHR4SW5kZXg6IG51bWJlciwgc3R4QmxvY2tIZWlnaHQ6IG51bWJlciwgYmxvY2tIZWFkZXI6IEJ1ZmZlcixcbiAgICAgICAgICAgICAgICBwcm9vZjogQnVmZmVyW10sIHR4RGV0YWlsOiBhbnksIGJsb2NrRGV0YWlsOiBhbnkpIHtcbiAgICAgICAgdGhpcy50eCA9IHR4XG4gICAgICAgIHRoaXMudHhJZCA9IHR4SWRcbiAgICAgICAgdGhpcy50eEluZGV4ID0gdHhJbmRleFxuICAgICAgICB0aGlzLnN0eEJsb2NrSGVpZ2h0ID0gc3R4QmxvY2tIZWlnaHRcbiAgICAgICAgdGhpcy5ibG9ja0hlYWRlciA9IGJsb2NrSGVhZGVyXG4gICAgICAgIHRoaXMucHJvb2YgPSBwcm9vZlxuICAgICAgICB0aGlzLnR4RGV0YWlsID0gdHhEZXRhaWxcbiAgICAgICAgdGhpcy5ibG9ja0RldGFpbCA9IGJsb2NrRGV0YWlsXG4gICAgfVxuXG4gICAgLy8gVE9ETyBUaGVyZSBpcyBzb21lIGtpbmQgb2YgcmFjZSBjb25kaXRpb24gb3IgYnVmZmVyIG92ZXJydW4gaGFwcGVuaW5nIHdoZW4gdGhpcyBmdW5jdGlvbiBnZXRzIGNhbGxlZCBtb3JlIHRoYW4gb25jZVxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgZnJvbVR4SWQodHhJZDogc3RyaW5nIHwgQnVmZmVyKTogUHJvbWlzZTxQcm92YWJsZVR4PiB7XG4gICAgICAgIGNvbnN0IHR4SWRIZXggPSBoZXhPckJ1ZmZlclRvSGV4KHR4SWQpXG4gICAgICAgIGNvbnN0IHR4RGV0YWlsID0gYXdhaXQgZ2V0VHJhbnNhY3Rpb25EZXRhaWxzKHR4SWRIZXgpXG4gICAgICAgIGNvbnN0IHR4ID0gQnVmZmVyLmZyb20odHhEZXRhaWwuaGV4LCAnaGV4JylcbiAgICAgICAgbGV0IHR4V2l0aG91dFNlZ3dpdFxuXG4gICAgICAgIGNvbnN0IGlzU2Vnd2l0ID0gdHgucmVhZEludDgoU0VHV0lUX01BUktFUl9PRkZTRVQpID09PSAwXG4gICAgICAgIGNvbnN0IHNlZ3dpdEZsYWcgPSBpc1NlZ3dpdCA/IHR4LnJlYWRJbnQ4KFNFR1dJVF9GTEFHX09GRlNFVCkgOiAwXG4gICAgICAgIGlmIChpc1NlZ3dpdCkge1xuICAgICAgICAgICAgaWYgKHNlZ3dpdEZsYWcgPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0eFdpdGhvdXRTZWd3aXQgPSBUcmFuc2FjdGlvbi5mcm9tSGV4KHR4RGV0YWlsLmhleClcbiAgICAgICAgICAgICAgICAgICAgLnRvQnVmZmVyKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmYWxzZSkgLy8gVE9ETyBUaGlzIHJlcXVpcmVzIGEgaGFja2VkIGJpdGNvaW5qcy1saWJcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJ1bmtub3duIHNlZ3dpdCBmbGFnIHZhbHVlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJsb2NrSGVhZGVyID0gQnVmZmVyLmZyb20oYXdhaXQgZ2V0UmF3QmxvY2tIZWFkZXIodHhEZXRhaWwuYmxvY2toYXNoKSwgJ2hleCcpXG4gICAgICAgIGNvbnN0IGJsb2NrRGV0YWlsID0gYXdhaXQgZ2V0QmxvY2tTdGF0cyh0eERldGFpbC5ibG9ja2hhc2gpXG4gICAgICAgIGNvbnN0IHN0eEJsb2NrSGVpZ2h0ID0gYXdhaXQgZ2V0U3R4QmxvY2tIZWlnaHQoYmxvY2tEZXRhaWwuaGVpZ2h0KSBhcyBudW1iZXJcbiAgICAgICAgY29uc3QgdHhJbmRleCA9IGJsb2NrRGV0YWlsLnR4LmZpbmRJbmRleCgoaWQ6IHN0cmluZykgPT4gaWQgPT09IHR4SWQpXG5cbiAgICAgICAgY29uc3QgdHJlZSA9IG5ldyBNZXJrbGVUcmVlKGJsb2NrRGV0YWlsLnR4LCBTSEEyNTYsIHtpc0JpdGNvaW5UcmVlOiB0cnVlfSlcbiAgICAgICAgY29uc3QgcHJvb2YgPSB0cmVlLmdldFByb29mKGJsb2NrRGV0YWlsLnR4LCB0eEluZGV4KS5tYXAocCA9PiBwLmRhdGEpXG4gICAgICAgIHJldHVybiBuZXcgUHJvdmFibGVUeChcbiAgICAgICAgICAgIHR4V2l0aG91dFNlZ3dpdCB8fCB0eCxcbiAgICAgICAgICAgIGhleE9yQnVmZmVyVG9CdWZmZXIodHhJZCksXG4gICAgICAgICAgICB0eEluZGV4LFxuICAgICAgICAgICAgc3R4QmxvY2tIZWlnaHQsXG4gICAgICAgICAgICBibG9ja0hlYWRlcixcbiAgICAgICAgICAgIHByb29mLFxuICAgICAgICAgICAgdHhEZXRhaWwsXG4gICAgICAgICAgICBibG9ja0RldGFpbFxuICAgICAgICApXG4gICAgfVxuXG4gICAgdG9Db21wYWN0UHJvb2ZDVigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbXBhY3RIZWFkZXI6IHRoaXMuZ2V0Q29tcGFjdEhlYWRlckNWKCksXG4gICAgICAgICAgICB0eDogYnVmZmVyQ1YodGhpcy50eCksXG4gICAgICAgICAgICBwcm9vZjogdGhpcy5nZXRQcm9vZkNWKCksXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b1Byb29mQ1YoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWFkZXI6IHRoaXMuZ2V0SGVhZGVyQ1YoKSxcbiAgICAgICAgICAgIHR4OiBidWZmZXJDVih0aGlzLnR4KSxcbiAgICAgICAgICAgIHByb29mOiB0aGlzLmdldFByb29mQ1YoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRIZWFkZXJDVigpIHtcbiAgICAgICAgcmV0dXJuIHR1cGxlQ1Yoe1xuICAgICAgICAgICAgdmVyc2lvbjogYnVmZmVyQ1YocmV2ZXJzZUJ1ZmZlcihCdWZmZXIuZnJvbSh0aGlzLmJsb2NrRGV0YWlsLnZlcnNpb25IZXgsICdoZXgnKSkpLFxuICAgICAgICAgICAgcGFyZW50OiBidWZmZXJDVihyZXZlcnNlQnVmZmVyKEJ1ZmZlci5mcm9tKHRoaXMuYmxvY2tEZXRhaWwucHJldmlvdXNibG9ja2hhc2gsICdoZXgnKSkpLFxuICAgICAgICAgICAgJ21lcmtsZS1yb290JzogYnVmZmVyQ1YocmV2ZXJzZUJ1ZmZlcihCdWZmZXIuZnJvbSh0aGlzLmJsb2NrRGV0YWlsLm1lcmtsZXJvb3QsICdoZXgnKSkpLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBidWZmZXJDVihudW1iZXJUb0J1ZmZlcih0aGlzLmJsb2NrRGV0YWlsLnRpbWUsIDQpKSxcbiAgICAgICAgICAgIG5iaXRzOiBidWZmZXJDVihyZXZlcnNlQnVmZmVyKEJ1ZmZlci5mcm9tKHRoaXMuYmxvY2tEZXRhaWwuYml0cywgJ2hleCcpKSksXG4gICAgICAgICAgICBub25jZTogYnVmZmVyQ1YobnVtYmVyVG9CdWZmZXIodGhpcy5ibG9ja0RldGFpbC5ub25jZSwgNCkpLFxuICAgICAgICAgICAgaGVpZ2h0OiB1aW50Q1YodGhpcy5zdHhCbG9ja0hlaWdodClcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRQcm9vZkNWKCkge1xuICAgICAgICByZXR1cm4gdHVwbGVDVih7XG4gICAgICAgICAgICBcInR4LWluZGV4XCI6IHVpbnRDVih0aGlzLnR4SW5kZXgpLFxuICAgICAgICAgICAgaGFzaGVzOiBsaXN0Q1Y8QnVmZmVyQ1Y+KHRoaXMucHJvb2YubWFwKHAgPT4gYnVmZmVyQ1YocmV2ZXJzZUJ1ZmZlcihwKSkpKSxcbiAgICAgICAgICAgIFwidHJlZS1kZXB0aFwiOiB1aW50Q1YodGhpcy5wcm9vZi5sZW5ndGgpXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0Q29tcGFjdEhlYWRlckNWKCkge1xuICAgICAgICByZXR1cm4gdHVwbGVDVih7XG4gICAgICAgICAgICBoZWFkZXI6IGJ1ZmZlckNWKHRoaXMuYmxvY2tIZWFkZXIpLFxuICAgICAgICAgICAgaGVpZ2h0OiB1aW50Q1YodGhpcy5zdHhCbG9ja0hlaWdodClcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl19
import { getBlock, getBlockHeader, getRawTransaction } from "./rpcclient.js"; // TODO Why is the .js extension required?
import 'dotenv/config';
import { MerkleTree } from "merkletreejs";
import SHA256 from "crypto-js/sha256.js";
import { getBlockHeaderHash } from "./ClarityBitcoinClient.js";
import { getStxBlockHeight } from "./BlockApiClient.js";
const { CLARITY_BITCOIN_CONTRACT_NAME, CLARITY_BITCOIN_CONTRACT_ADDRESS, NETWORK, SENDER_ADDRESS } = process.env;
const txid = "20f85e35d02e28ac89db8764e280db560de1baaa3ce66f15dcea349fb137879c";
const getTxProof = async (txId) => {
    // TODO Make this work for segwit txs
    // console.log(await getRawTransaction(txid, true))
    const { blockhash, hex } = await getRawTransaction(txid, true);
    const tx = Buffer.from(hex, 'hex');
    // console.log(tx.length)
    const blockHeader = Buffer.from(await getBlockHeader(blockhash), 'hex');
    // console.log(reverseBuffer(blockHeader.subarray(36, 68)).toString('hex'))
    const { tx: txIds, height } = await getBlock(blockhash, 1);
    const stxBlockHeight = await getStxBlockHeight(height);
    const txIndex = txIds.findIndex((id) => id === txId);
    const tree = new MerkleTree(txIds, SHA256, { isBitcoinTree: true });
    // console.log(tree.toString())
    const treeDepth = tree.getDepth();
    const proof = tree.getProof(txId, txIndex).map(p => p.data);
    console.assert(proof.length === treeDepth, "treeDepth and proof don't match");
    return { tx, txId, txIndex, stxBlockHeight, blockHeader, proof };
};
getTxProof(txid)
    .then(({ blockHeader, stxBlockHeight }) => getBlockHeaderHash(stxBlockHeight))
    // .then(({blockHeader, stxBlockHeight}: ProvableTx) =>
    //     verifyBlockHeader(blockHeader, stxBlockHeight))
    // .then(({ stxBlockHeight, blockHeader, tx, txIndex, proof }: ProvableTx) =>
    //     verifyProofOnStacks(stxBlockHeight, blockHeader, tx, txIndex, proof))
    // .then(async ({tx, txId}: ProvableTx): Promise<Buffer> => {
    //     const result = await getReversedTxId(tx)
    //     console.assert(reverseBuffer(Buffer.from(txId, 'hex')).equals(result), txId)
    //     return result
    // })
    .then(console.log)
    .catch(console.error);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsUUFBUSxFQUFFLGNBQWMsRUFBRSxpQkFBaUIsRUFBQyxNQUFNLGdCQUFnQixDQUFBLENBQUMsMENBQTBDO0FBQ3JILE9BQU8sZUFBZSxDQUFBO0FBQ3RCLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxjQUFjLENBQUE7QUFDdkMsT0FBTyxNQUFNLE1BQU0scUJBQXFCLENBQUE7QUFDeEMsT0FBTyxFQUEwRCxrQkFBa0IsRUFBQyxNQUFNLDJCQUEyQixDQUFBO0FBQ3JILE9BQU8sRUFBQyxpQkFBaUIsRUFBQyxNQUFNLHFCQUFxQixDQUFBO0FBRXJELE1BQU0sRUFDRiw2QkFBNkIsRUFDN0IsZ0NBQWdDLEVBQ2hDLE9BQU8sRUFDUCxjQUFjLEVBQ2pCLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQTtBQVdmLE1BQU0sSUFBSSxHQUFHLGtFQUFrRSxDQUFBO0FBRS9FLE1BQU0sVUFBVSxHQUFHLEtBQUssRUFBRSxJQUFZLEVBQXVCLEVBQUU7SUFDM0QscUNBQXFDO0lBQ3JDLG1EQUFtRDtJQUNuRCxNQUFNLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxHQUFHLE1BQU0saUJBQWlCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFBO0lBQzlELE1BQU0sRUFBRSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFBO0lBQ2xDLHlCQUF5QjtJQUN6QixNQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sY0FBYyxDQUFDLFNBQVMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFBO0lBQ3ZFLDJFQUEyRTtJQUMzRSxNQUFNLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsR0FBRyxNQUFNLFFBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUE7SUFDMUQsTUFBTSxjQUFjLEdBQUcsTUFBTSxpQkFBaUIsQ0FBQyxNQUFNLENBQVcsQ0FBQTtJQUNoRSxNQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBVSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEtBQUssSUFBSSxDQUFDLENBQUM7SUFDN0QsTUFBTSxJQUFJLEdBQUcsSUFBSSxVQUFVLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxFQUFFLGFBQWEsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQ3BFLCtCQUErQjtJQUMvQixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDbEMsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRTVELE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sS0FBSyxTQUFTLEVBQUUsaUNBQWlDLENBQUMsQ0FBQTtJQUU3RSxPQUFPLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsY0FBYyxFQUFFLFdBQVcsRUFBRSxLQUFLLEVBQUUsQ0FBQTtBQUNwRSxDQUFDLENBQUE7QUFFRCxVQUFVLENBQUMsSUFBSSxDQUFDO0tBQ1gsSUFBSSxDQUFDLENBQUMsRUFBQyxXQUFXLEVBQUUsY0FBYyxFQUFhLEVBQUUsRUFBRSxDQUFDLGtCQUFrQixDQUFDLGNBQWMsQ0FBQyxDQUFDO0lBQ3hGLHVEQUF1RDtJQUN2RCxzREFBc0Q7SUFDdEQsNkVBQTZFO0lBQzdFLDRFQUE0RTtJQUM1RSw2REFBNkQ7SUFDN0QsK0NBQStDO0lBQy9DLG1GQUFtRjtJQUNuRixvQkFBb0I7SUFDcEIsS0FBSztLQUNKLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO0tBQ2pCLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2dldEJsb2NrLCBnZXRCbG9ja0hlYWRlciwgZ2V0UmF3VHJhbnNhY3Rpb259IGZyb20gXCIuL3JwY2NsaWVudC5qc1wiIC8vIFRPRE8gV2h5IGlzIHRoZSAuanMgZXh0ZW5zaW9uIHJlcXVpcmVkP1xuaW1wb3J0ICdkb3RlbnYvY29uZmlnJ1xuaW1wb3J0IHtNZXJrbGVUcmVlfSBmcm9tIFwibWVya2xldHJlZWpzXCJcbmltcG9ydCBTSEEyNTYgZnJvbSBcImNyeXB0by1qcy9zaGEyNTYuanNcIlxuaW1wb3J0IHt2ZXJpZnlCbG9ja0hlYWRlciwgZ2V0UmV2ZXJzZWRUeElkLCB2ZXJpZnlQcm9vZk9uU3RhY2tzLCBnZXRCbG9ja0hlYWRlckhhc2h9IGZyb20gXCIuL0NsYXJpdHlCaXRjb2luQ2xpZW50LmpzXCJcbmltcG9ydCB7Z2V0U3R4QmxvY2tIZWlnaHR9IGZyb20gXCIuL0Jsb2NrQXBpQ2xpZW50LmpzXCJcblxuY29uc3Qge1xuICAgIENMQVJJVFlfQklUQ09JTl9DT05UUkFDVF9OQU1FLFxuICAgIENMQVJJVFlfQklUQ09JTl9DT05UUkFDVF9BRERSRVNTLFxuICAgIE5FVFdPUkssXG4gICAgU0VOREVSX0FERFJFU1Ncbn0gPSBwcm9jZXNzLmVudlxuXG5pbnRlcmZhY2UgUHJvdmFibGVUeCB7XG4gICAgdHg6IEJ1ZmZlcixcbiAgICB0eElkOiBzdHJpbmcsXG4gICAgdHhJbmRleDogbnVtYmVyLFxuICAgIHN0eEJsb2NrSGVpZ2h0OiBudW1iZXIsXG4gICAgYmxvY2tIZWFkZXI6IEJ1ZmZlcixcbiAgICBwcm9vZjogQnVmZmVyW10sXG59XG5cbmNvbnN0IHR4aWQgPSBcIjIwZjg1ZTM1ZDAyZTI4YWM4OWRiODc2NGUyODBkYjU2MGRlMWJhYWEzY2U2NmYxNWRjZWEzNDlmYjEzNzg3OWNcIlxuXG5jb25zdCBnZXRUeFByb29mID0gYXN5bmMgKHR4SWQ6IHN0cmluZyk6IFByb21pc2U8UHJvdmFibGVUeD4gPT4ge1xuICAgIC8vIFRPRE8gTWFrZSB0aGlzIHdvcmsgZm9yIHNlZ3dpdCB0eHNcbiAgICAvLyBjb25zb2xlLmxvZyhhd2FpdCBnZXRSYXdUcmFuc2FjdGlvbih0eGlkLCB0cnVlKSlcbiAgICBjb25zdCB7IGJsb2NraGFzaCwgaGV4IH0gPSBhd2FpdCBnZXRSYXdUcmFuc2FjdGlvbih0eGlkLCB0cnVlKVxuICAgIGNvbnN0IHR4ID0gQnVmZmVyLmZyb20oaGV4LCAnaGV4JylcbiAgICAvLyBjb25zb2xlLmxvZyh0eC5sZW5ndGgpXG4gICAgY29uc3QgYmxvY2tIZWFkZXIgPSBCdWZmZXIuZnJvbShhd2FpdCBnZXRCbG9ja0hlYWRlcihibG9ja2hhc2gpLCAnaGV4JylcbiAgICAvLyBjb25zb2xlLmxvZyhyZXZlcnNlQnVmZmVyKGJsb2NrSGVhZGVyLnN1YmFycmF5KDM2LCA2OCkpLnRvU3RyaW5nKCdoZXgnKSlcbiAgICBjb25zdCB7IHR4OiB0eElkcywgaGVpZ2h0IH0gPSBhd2FpdCBnZXRCbG9jayhibG9ja2hhc2gsIDEpXG4gICAgY29uc3Qgc3R4QmxvY2tIZWlnaHQgPSBhd2FpdCBnZXRTdHhCbG9ja0hlaWdodChoZWlnaHQpIGFzIG51bWJlclxuICAgIGNvbnN0IHR4SW5kZXggPSB0eElkcy5maW5kSW5kZXgoKGlkOiBzdHJpbmcpID0+IGlkID09PSB0eElkKTtcbiAgICBjb25zdCB0cmVlID0gbmV3IE1lcmtsZVRyZWUodHhJZHMsIFNIQTI1NiwgeyBpc0JpdGNvaW5UcmVlOiB0cnVlIH0pO1xuICAgIC8vIGNvbnNvbGUubG9nKHRyZWUudG9TdHJpbmcoKSlcbiAgICBjb25zdCB0cmVlRGVwdGggPSB0cmVlLmdldERlcHRoKCk7XG4gICAgY29uc3QgcHJvb2YgPSB0cmVlLmdldFByb29mKHR4SWQsIHR4SW5kZXgpLm1hcChwID0+IHAuZGF0YSk7XG5cbiAgICBjb25zb2xlLmFzc2VydChwcm9vZi5sZW5ndGggPT09IHRyZWVEZXB0aCwgXCJ0cmVlRGVwdGggYW5kIHByb29mIGRvbid0IG1hdGNoXCIpXG5cbiAgICByZXR1cm4geyB0eCwgdHhJZCwgdHhJbmRleCwgc3R4QmxvY2tIZWlnaHQsIGJsb2NrSGVhZGVyLCBwcm9vZiB9XG59XG5cbmdldFR4UHJvb2YodHhpZClcbiAgICAudGhlbigoe2Jsb2NrSGVhZGVyLCBzdHhCbG9ja0hlaWdodH06IFByb3ZhYmxlVHgpID0+IGdldEJsb2NrSGVhZGVySGFzaChzdHhCbG9ja0hlaWdodCkpXG4gICAgLy8gLnRoZW4oKHtibG9ja0hlYWRlciwgc3R4QmxvY2tIZWlnaHR9OiBQcm92YWJsZVR4KSA9PlxuICAgIC8vICAgICB2ZXJpZnlCbG9ja0hlYWRlcihibG9ja0hlYWRlciwgc3R4QmxvY2tIZWlnaHQpKVxuICAgIC8vIC50aGVuKCh7IHN0eEJsb2NrSGVpZ2h0LCBibG9ja0hlYWRlciwgdHgsIHR4SW5kZXgsIHByb29mIH06IFByb3ZhYmxlVHgpID0+XG4gICAgLy8gICAgIHZlcmlmeVByb29mT25TdGFja3Moc3R4QmxvY2tIZWlnaHQsIGJsb2NrSGVhZGVyLCB0eCwgdHhJbmRleCwgcHJvb2YpKVxuICAgIC8vIC50aGVuKGFzeW5jICh7dHgsIHR4SWR9OiBQcm92YWJsZVR4KTogUHJvbWlzZTxCdWZmZXI+ID0+IHtcbiAgICAvLyAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0UmV2ZXJzZWRUeElkKHR4KVxuICAgIC8vICAgICBjb25zb2xlLmFzc2VydChyZXZlcnNlQnVmZmVyKEJ1ZmZlci5mcm9tKHR4SWQsICdoZXgnKSkuZXF1YWxzKHJlc3VsdCksIHR4SWQpXG4gICAgLy8gICAgIHJldHVybiByZXN1bHRcbiAgICAvLyB9KVxuICAgIC50aGVuKGNvbnNvbGUubG9nKVxuICAgIC5jYXRjaChjb25zb2xlLmVycm9yKSJdfQ==
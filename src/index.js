import { getBlock, getBlockHeader, getRawTransaction } from "./rpcclient.js"; // TODO Why is the .js extension required?
import { callReadOnlyFunction, cvToValue, uintCV, } from "@stacks/transactions";
import 'dotenv/config';
import { MerkleTree } from "merkletreejs";
import SHA256 from "crypto-js/sha256.js";
import { verifyProofOnStacks } from "./ClarityBitcoinClient.js";
import { getStxBlockHeight } from "./BlockApiClient.js";
const { CLARITY_BITCOIN_CONTRACT_NAME, CLARITY_BITCOIN_CONTRACT_ADDRESS, NETWORK, SENDER_ADDRESS } = process.env;
const txid = "20f85e35d02e28ac89db8764e280db560de1baaa3ce66f15dcea349fb137879c";
const getTxProof = async (txId) => {
    // TODO Make this work for segwit txs
    // console.log(await getRawTransaction(txid, true))
    const { blockhash, hex } = await getRawTransaction(txid, true);
    const tx = Buffer.from(hex, 'hex');
    // console.log(tx.length)
    const blockHeader = Buffer.from(await getBlockHeader(blockhash), 'hex');
    // console.log(reverseBuffer(blockHeader.subarray(36, 68)).toString('hex'))
    const { tx: txIds, height } = await getBlock(blockhash, 1);
    const stxBlockHeight = await getStxBlockHeight(height);
    const txIndex = txIds.findIndex((id) => id === txId);
    const tree = new MerkleTree(txIds, SHA256, { isBitcoinTree: true });
    // console.log(tree.toString())
    const treeDepth = tree.getDepth();
    const proof = tree.getProof(txId, txIndex).map(p => p.data);
    console.assert(proof.length === treeDepth, "treeDepth and proof don't match");
    return { tx, txId, txIndex, stxBlockHeight, blockHeader, proof };
};
const getBlockHeaderHash = async (blockHeight) => {
    // (get-bc-h-hash (bh uint))
    const functionName = 'get-bc-h-hash';
    const functionArgs = [
        uintCV(58225)
    ];
    const result = await callReadOnlyFunction({
        contractName: CLARITY_BITCOIN_CONTRACT_NAME,
        contractAddress: CLARITY_BITCOIN_CONTRACT_ADDRESS,
        functionName,
        functionArgs,
        network: NETWORK,
        senderAddress: SENDER_ADDRESS,
    });
    return cvToValue(result);
};
getTxProof(txid)
    // .then(getBlockHeaderHash)
    // .then(({blockHeader, stxBlockHeight}: ProvableTx) =>
    //     verifyBlockHeader(blockHeader, stxBlockHeight))
    .then(({ stxBlockHeight, blockHeader, tx, txIndex, proof }) => verifyProofOnStacks(stxBlockHeight, blockHeader, tx, txIndex, proof))
    // .then(async ({tx, txId}: ProvableTx): Promise<Buffer> => {
    //     const result = await getReversedTxId(tx)
    //     console.assert(reverseBuffer(Buffer.from(txId, 'hex')).equals(result), txId)
    //     return result
    // })
    .then(console.log)
    .catch(console.error);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsUUFBUSxFQUFFLGNBQWMsRUFBRSxpQkFBaUIsRUFBQyxNQUFNLGdCQUFnQixDQUFBLENBQUMsMENBQTBDO0FBQ3JILE9BQU8sRUFHSCxvQkFBb0IsRUFFcEIsU0FBUyxFQUdULE1BQU0sR0FDVCxNQUFNLHNCQUFzQixDQUFBO0FBQzdCLE9BQU8sZUFBZSxDQUFBO0FBQ3RCLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxjQUFjLENBQUE7QUFDdkMsT0FBTyxNQUFNLE1BQU0scUJBQXFCLENBQUE7QUFDeEMsT0FBTyxFQUFxQyxtQkFBbUIsRUFBQyxNQUFNLDJCQUEyQixDQUFBO0FBQ2pHLE9BQU8sRUFBQyxpQkFBaUIsRUFBQyxNQUFNLHFCQUFxQixDQUFBO0FBRXJELE1BQU0sRUFDRiw2QkFBNkIsRUFDN0IsZ0NBQWdDLEVBQ2hDLE9BQU8sRUFDUCxjQUFjLEVBQ2pCLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQTtBQVdmLE1BQU0sSUFBSSxHQUFHLGtFQUFrRSxDQUFBO0FBRS9FLE1BQU0sVUFBVSxHQUFHLEtBQUssRUFBRSxJQUFZLEVBQXVCLEVBQUU7SUFDM0QscUNBQXFDO0lBQ3JDLG1EQUFtRDtJQUNuRCxNQUFNLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxHQUFHLE1BQU0saUJBQWlCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFBO0lBQzlELE1BQU0sRUFBRSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFBO0lBQ2xDLHlCQUF5QjtJQUN6QixNQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sY0FBYyxDQUFDLFNBQVMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFBO0lBQ3ZFLDJFQUEyRTtJQUMzRSxNQUFNLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsR0FBRyxNQUFNLFFBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUE7SUFDMUQsTUFBTSxjQUFjLEdBQUcsTUFBTSxpQkFBaUIsQ0FBQyxNQUFNLENBQVcsQ0FBQTtJQUNoRSxNQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBVSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEtBQUssSUFBSSxDQUFDLENBQUM7SUFDN0QsTUFBTSxJQUFJLEdBQUcsSUFBSSxVQUFVLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxFQUFFLGFBQWEsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQ3BFLCtCQUErQjtJQUMvQixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDbEMsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRTVELE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sS0FBSyxTQUFTLEVBQUUsaUNBQWlDLENBQUMsQ0FBQTtJQUU3RSxPQUFPLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsY0FBYyxFQUFFLFdBQVcsRUFBRSxLQUFLLEVBQUUsQ0FBQTtBQUNwRSxDQUFDLENBQUE7QUFHRCxNQUFNLGtCQUFrQixHQUFHLEtBQUssRUFBRSxXQUFtQixFQUFnQixFQUFFO0lBQ25FLDRCQUE0QjtJQUM1QixNQUFNLFlBQVksR0FBRyxlQUFlLENBQUE7SUFDcEMsTUFBTSxZQUFZLEdBQW1CO1FBQ2pDLE1BQU0sQ0FBQyxLQUFLLENBQUM7S0FDaEIsQ0FBQTtJQUVELE1BQU0sTUFBTSxHQUFHLE1BQU0sb0JBQW9CLENBQUM7UUFDdEMsWUFBWSxFQUFFLDZCQUF1QztRQUNyRCxlQUFlLEVBQUUsZ0NBQTBDO1FBQzNELFlBQVk7UUFDWixZQUFZO1FBQ1osT0FBTyxFQUFFLE9BQWM7UUFDdkIsYUFBYSxFQUFFLGNBQXdCO0tBQzFDLENBQUMsQ0FBQTtJQUNGLE9BQU8sU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFBO0FBRTVCLENBQUMsQ0FBQTtBQUVELFVBQVUsQ0FBQyxJQUFJLENBQUM7SUFDWiw0QkFBNEI7SUFDNUIsdURBQXVEO0lBQ3ZELHNEQUFzRDtLQUNyRCxJQUFJLENBQUMsQ0FBQyxFQUFFLGNBQWMsRUFBRSxXQUFXLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQWMsRUFBRSxFQUFFLENBQ3RFLG1CQUFtQixDQUFDLGNBQWMsRUFBRSxXQUFXLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztJQUN6RSw2REFBNkQ7SUFDN0QsK0NBQStDO0lBQy9DLG1GQUFtRjtJQUNuRixvQkFBb0I7SUFDcEIsS0FBSztLQUNKLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO0tBQ2pCLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2dldEJsb2NrLCBnZXRCbG9ja0hlYWRlciwgZ2V0UmF3VHJhbnNhY3Rpb259IGZyb20gXCIuL3JwY2NsaWVudC5qc1wiIC8vIFRPRE8gV2h5IGlzIHRoZSAuanMgZXh0ZW5zaW9uIHJlcXVpcmVkP1xuaW1wb3J0IHtcbiAgICBCdWZmZXJDVixcbiAgICBidWZmZXJDVixcbiAgICBjYWxsUmVhZE9ubHlGdW5jdGlvbixcbiAgICBDbGFyaXR5VmFsdWUsXG4gICAgY3ZUb1ZhbHVlLFxuICAgIGxpc3RDVixcbiAgICB0dXBsZUNWLFxuICAgIHVpbnRDVixcbn0gZnJvbSBcIkBzdGFja3MvdHJhbnNhY3Rpb25zXCJcbmltcG9ydCAnZG90ZW52L2NvbmZpZydcbmltcG9ydCB7TWVya2xlVHJlZX0gZnJvbSBcIm1lcmtsZXRyZWVqc1wiXG5pbXBvcnQgU0hBMjU2IGZyb20gXCJjcnlwdG8tanMvc2hhMjU2LmpzXCJcbmltcG9ydCB7dmVyaWZ5QmxvY2tIZWFkZXIsIGdldFJldmVyc2VkVHhJZCwgdmVyaWZ5UHJvb2ZPblN0YWNrc30gZnJvbSBcIi4vQ2xhcml0eUJpdGNvaW5DbGllbnQuanNcIlxuaW1wb3J0IHtnZXRTdHhCbG9ja0hlaWdodH0gZnJvbSBcIi4vQmxvY2tBcGlDbGllbnQuanNcIlxuXG5jb25zdCB7XG4gICAgQ0xBUklUWV9CSVRDT0lOX0NPTlRSQUNUX05BTUUsXG4gICAgQ0xBUklUWV9CSVRDT0lOX0NPTlRSQUNUX0FERFJFU1MsXG4gICAgTkVUV09SSyxcbiAgICBTRU5ERVJfQUREUkVTU1xufSA9IHByb2Nlc3MuZW52XG5cbmludGVyZmFjZSBQcm92YWJsZVR4IHtcbiAgICB0eDogQnVmZmVyLFxuICAgIHR4SWQ6IHN0cmluZyxcbiAgICB0eEluZGV4OiBudW1iZXIsXG4gICAgc3R4QmxvY2tIZWlnaHQ6IG51bWJlcixcbiAgICBibG9ja0hlYWRlcjogQnVmZmVyLFxuICAgIHByb29mOiBCdWZmZXJbXSxcbn1cblxuY29uc3QgdHhpZCA9IFwiMjBmODVlMzVkMDJlMjhhYzg5ZGI4NzY0ZTI4MGRiNTYwZGUxYmFhYTNjZTY2ZjE1ZGNlYTM0OWZiMTM3ODc5Y1wiXG5cbmNvbnN0IGdldFR4UHJvb2YgPSBhc3luYyAodHhJZDogc3RyaW5nKTogUHJvbWlzZTxQcm92YWJsZVR4PiA9PiB7XG4gICAgLy8gVE9ETyBNYWtlIHRoaXMgd29yayBmb3Igc2Vnd2l0IHR4c1xuICAgIC8vIGNvbnNvbGUubG9nKGF3YWl0IGdldFJhd1RyYW5zYWN0aW9uKHR4aWQsIHRydWUpKVxuICAgIGNvbnN0IHsgYmxvY2toYXNoLCBoZXggfSA9IGF3YWl0IGdldFJhd1RyYW5zYWN0aW9uKHR4aWQsIHRydWUpXG4gICAgY29uc3QgdHggPSBCdWZmZXIuZnJvbShoZXgsICdoZXgnKVxuICAgIC8vIGNvbnNvbGUubG9nKHR4Lmxlbmd0aClcbiAgICBjb25zdCBibG9ja0hlYWRlciA9IEJ1ZmZlci5mcm9tKGF3YWl0IGdldEJsb2NrSGVhZGVyKGJsb2NraGFzaCksICdoZXgnKVxuICAgIC8vIGNvbnNvbGUubG9nKHJldmVyc2VCdWZmZXIoYmxvY2tIZWFkZXIuc3ViYXJyYXkoMzYsIDY4KSkudG9TdHJpbmcoJ2hleCcpKVxuICAgIGNvbnN0IHsgdHg6IHR4SWRzLCBoZWlnaHQgfSA9IGF3YWl0IGdldEJsb2NrKGJsb2NraGFzaCwgMSlcbiAgICBjb25zdCBzdHhCbG9ja0hlaWdodCA9IGF3YWl0IGdldFN0eEJsb2NrSGVpZ2h0KGhlaWdodCkgYXMgbnVtYmVyXG4gICAgY29uc3QgdHhJbmRleCA9IHR4SWRzLmZpbmRJbmRleCgoaWQ6IHN0cmluZykgPT4gaWQgPT09IHR4SWQpO1xuICAgIGNvbnN0IHRyZWUgPSBuZXcgTWVya2xlVHJlZSh0eElkcywgU0hBMjU2LCB7IGlzQml0Y29pblRyZWU6IHRydWUgfSk7XG4gICAgLy8gY29uc29sZS5sb2codHJlZS50b1N0cmluZygpKVxuICAgIGNvbnN0IHRyZWVEZXB0aCA9IHRyZWUuZ2V0RGVwdGgoKTtcbiAgICBjb25zdCBwcm9vZiA9IHRyZWUuZ2V0UHJvb2YodHhJZCwgdHhJbmRleCkubWFwKHAgPT4gcC5kYXRhKTtcblxuICAgIGNvbnNvbGUuYXNzZXJ0KHByb29mLmxlbmd0aCA9PT0gdHJlZURlcHRoLCBcInRyZWVEZXB0aCBhbmQgcHJvb2YgZG9uJ3QgbWF0Y2hcIilcblxuICAgIHJldHVybiB7IHR4LCB0eElkLCB0eEluZGV4LCBzdHhCbG9ja0hlaWdodCwgYmxvY2tIZWFkZXIsIHByb29mIH1cbn1cblxuXG5jb25zdCBnZXRCbG9ja0hlYWRlckhhc2ggPSBhc3luYyAoYmxvY2tIZWlnaHQ6IG51bWJlcik6IFByb21pc2U8YW55PiA9PiB7XG4gICAgLy8gKGdldC1iYy1oLWhhc2ggKGJoIHVpbnQpKVxuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9ICdnZXQtYmMtaC1oYXNoJ1xuICAgIGNvbnN0IGZ1bmN0aW9uQXJnczogQ2xhcml0eVZhbHVlW10gPSBbXG4gICAgICAgIHVpbnRDVig1ODIyNSlcbiAgICBdXG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYWxsUmVhZE9ubHlGdW5jdGlvbih7XG4gICAgICAgIGNvbnRyYWN0TmFtZTogQ0xBUklUWV9CSVRDT0lOX0NPTlRSQUNUX05BTUUgYXMgc3RyaW5nLFxuICAgICAgICBjb250cmFjdEFkZHJlc3M6IENMQVJJVFlfQklUQ09JTl9DT05UUkFDVF9BRERSRVNTIGFzIHN0cmluZyxcbiAgICAgICAgZnVuY3Rpb25OYW1lLFxuICAgICAgICBmdW5jdGlvbkFyZ3MsXG4gICAgICAgIG5ldHdvcms6IE5FVFdPUksgYXMgYW55LFxuICAgICAgICBzZW5kZXJBZGRyZXNzOiBTRU5ERVJfQUREUkVTUyBhcyBzdHJpbmcsXG4gICAgfSlcbiAgICByZXR1cm4gY3ZUb1ZhbHVlKHJlc3VsdClcblxufVxuXG5nZXRUeFByb29mKHR4aWQpXG4gICAgLy8gLnRoZW4oZ2V0QmxvY2tIZWFkZXJIYXNoKVxuICAgIC8vIC50aGVuKCh7YmxvY2tIZWFkZXIsIHN0eEJsb2NrSGVpZ2h0fTogUHJvdmFibGVUeCkgPT5cbiAgICAvLyAgICAgdmVyaWZ5QmxvY2tIZWFkZXIoYmxvY2tIZWFkZXIsIHN0eEJsb2NrSGVpZ2h0KSlcbiAgICAudGhlbigoeyBzdHhCbG9ja0hlaWdodCwgYmxvY2tIZWFkZXIsIHR4LCB0eEluZGV4LCBwcm9vZiB9OiBQcm92YWJsZVR4KSA9PlxuICAgICAgICB2ZXJpZnlQcm9vZk9uU3RhY2tzKHN0eEJsb2NrSGVpZ2h0LCBibG9ja0hlYWRlciwgdHgsIHR4SW5kZXgsIHByb29mKSlcbiAgICAvLyAudGhlbihhc3luYyAoe3R4LCB0eElkfTogUHJvdmFibGVUeCk6IFByb21pc2U8QnVmZmVyPiA9PiB7XG4gICAgLy8gICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFJldmVyc2VkVHhJZCh0eClcbiAgICAvLyAgICAgY29uc29sZS5hc3NlcnQocmV2ZXJzZUJ1ZmZlcihCdWZmZXIuZnJvbSh0eElkLCAnaGV4JykpLmVxdWFscyhyZXN1bHQpLCB0eElkKVxuICAgIC8vICAgICByZXR1cm4gcmVzdWx0XG4gICAgLy8gfSlcbiAgICAudGhlbihjb25zb2xlLmxvZylcbiAgICAuY2F0Y2goY29uc29sZS5lcnJvcikiXX0=
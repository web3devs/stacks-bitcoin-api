import { getBlock, getBlockHeader, getRawTransaction } from "./rpcclient.js"; // TODO Why is the .js extension required?
import { callReadOnlyFunction, listCV, tupleCV, uintCV, bufferCV, cvToValue, } from "@stacks/transactions";
import 'dotenv/config';
import { MerkleTree } from "merkletreejs";
import SHA256 from "crypto-js/sha256.js";
const { CLARITY_BITCOIN_CONTRACT_NAME, CLARITY_BITCOIN_CONTRACT_ADDRESS } = process.env;
const txid = "5a955dbb2f95609841e82a1fb2c913671e148eb21a923c6b5fe0e85314f63bb1";
const reverseBuffer = (src) => {
    var buffer = Buffer.alloc(src.length);
    for (var i = 0, j = src.length - 1; i <= j; ++i, --j) {
        buffer[i] = src[j];
        buffer[j] = src[i];
    }
    return buffer;
};
const getTxProof = async (txId) => {
    const { blockhash, hex } = await getRawTransaction(txid, true);
    const tx = Buffer.from(hex, 'hex');
    const blockHeader = Buffer.from(await getBlockHeader(blockhash), 'hex');
    const { tx: txIds, height: blockHeight } = await getBlock(blockhash, 1);
    const txIndex = txIds.findIndex((id) => id === txId);
    const tree = new MerkleTree(txIds, SHA256, { isBitcoinTree: true });
    const treeDepth = tree.getDepth();
    const proof = tree.getProof(txId, txIndex).map(p => reverseBuffer(p.data));
    return { tx, txId, txIndex, blockHeight, blockHeader, treeDepth, proof };
};
const verifyProofOnStacks = async ({ blockHeight, blockHeader, tx, txIndex, proof, treeDepth }) => {
    const functionName = 'was-tx-mined-compact';
    const functionArgs = [
        tupleCV({
            header: bufferCV(blockHeader),
            height: uintCV(blockHeight),
        }),
        bufferCV(tx),
        tupleCV({
            "tx-index": uintCV(txIndex),
            hashes: listCV(proof.map(p => bufferCV(p))),
            "tree-depth": uintCV(treeDepth)
        })
    ];
    const network = 'testnet';
    const senderAddress = 'ST24YYAWQ4DK4RKCKK1RP4PX0X5SCSXTWQXFGVCVY';
    const result = await callReadOnlyFunction({
        contractName: CLARITY_BITCOIN_CONTRACT_NAME,
        contractAddress: CLARITY_BITCOIN_CONTRACT_ADDRESS,
        functionName,
        functionArgs,
        network,
        senderAddress,
    });
    return cvToValue(result);
};
getTxProof(txid)
    .then(verifyProofOnStacks)
    .then(console.log) // FIXME Expecting true, getting false
    .catch(console.error);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsUUFBUSxFQUFFLGNBQWMsRUFBRSxpQkFBaUIsRUFBZ0IsTUFBTSxnQkFBZ0IsQ0FBQSxDQUFDLDBDQUEwQztBQUNwSSxPQUFPLEVBRUgsb0JBQW9CLEVBQ3BCLE1BQU0sRUFDTixPQUFPLEVBQ1AsTUFBTSxFQUVjLFFBQVEsRUFBRSxTQUFTLEdBQzFDLE1BQU0sc0JBQXNCLENBQUE7QUFDN0IsT0FBTyxlQUFlLENBQUE7QUFDdEIsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLGNBQWMsQ0FBQztBQUN4QyxPQUFPLE1BQU0sTUFBTSxxQkFBcUIsQ0FBQTtBQUV4QyxNQUFNLEVBQUMsNkJBQTZCLEVBQUUsZ0NBQWdDLEVBQUMsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFBO0FBWXJGLE1BQU0sSUFBSSxHQUFHLGtFQUFrRSxDQUFBO0FBRS9FLE1BQU0sYUFBYSxHQUFHLENBQUMsR0FBVyxFQUFVLEVBQUU7SUFDMUMsSUFBSSxNQUFNLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUE7SUFDckMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUU7UUFDbEQsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQTtRQUNsQixNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFBO0tBQ3JCO0lBQ0QsT0FBTyxNQUFNLENBQUE7QUFDakIsQ0FBQyxDQUFBO0FBRUQsTUFBTSxVQUFVLEdBQUcsS0FBSyxFQUFFLElBQVksRUFBdUIsRUFBRTtJQUMzRCxNQUFNLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxHQUFHLE1BQU0saUJBQWlCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFBO0lBQzlELE1BQU0sRUFBRSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFBO0lBQ2xDLE1BQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxjQUFjLENBQUMsU0FBUyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUE7SUFDdkUsTUFBTSxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBRSxHQUFHLE1BQU0sUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQTtJQUN2RSxNQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBVSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEtBQUssSUFBSSxDQUFDLENBQUM7SUFDN0QsTUFBTSxJQUFJLEdBQUcsSUFBSSxVQUFVLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxFQUFFLGFBQWEsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQ3BFLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNsQyxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFFM0UsT0FBTyxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxDQUFBO0FBQzVFLENBQUMsQ0FBQTtBQUVELE1BQU0sbUJBQW1CLEdBQUcsS0FBSyxFQUFFLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSxFQUFFLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQWMsRUFBZ0IsRUFBRTtJQUN4SCxNQUFNLFlBQVksR0FBRyxzQkFBc0IsQ0FBQTtJQUMzQyxNQUFNLFlBQVksR0FBbUI7UUFDakMsT0FBTyxDQUFDO1lBQ0osTUFBTSxFQUFFLFFBQVEsQ0FBQyxXQUFXLENBQUM7WUFDN0IsTUFBTSxFQUFFLE1BQU0sQ0FBQyxXQUFXLENBQUM7U0FDOUIsQ0FBQztRQUNGLFFBQVEsQ0FBQyxFQUFFLENBQUM7UUFDWixPQUFPLENBQUM7WUFDSixVQUFVLEVBQUUsTUFBTSxDQUFDLE9BQU8sQ0FBQztZQUMzQixNQUFNLEVBQUUsTUFBTSxDQUFXLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNyRCxZQUFZLEVBQUUsTUFBTSxDQUFDLFNBQVMsQ0FBQztTQUNsQyxDQUFDO0tBQ0wsQ0FBQTtJQUNELE1BQU0sT0FBTyxHQUFHLFNBQVMsQ0FBQTtJQUN6QixNQUFNLGFBQWEsR0FBRywyQ0FBMkMsQ0FBQTtJQUVqRSxNQUFNLE1BQU0sR0FBRyxNQUFNLG9CQUFvQixDQUFDO1FBQ3RDLFlBQVksRUFBRSw2QkFBdUM7UUFDckQsZUFBZSxFQUFFLGdDQUEwQztRQUMzRCxZQUFZO1FBQ1osWUFBWTtRQUNaLE9BQU87UUFDUCxhQUFhO0tBQ2hCLENBQUMsQ0FBQTtJQUNGLE9BQU8sU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFBO0FBQzVCLENBQUMsQ0FBQTtBQUVELFVBQVUsQ0FBQyxJQUFJLENBQUM7S0FDWCxJQUFJLENBQUMsbUJBQW1CLENBQUM7S0FDekIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxzQ0FBc0M7S0FDeEQsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Z2V0QmxvY2ssIGdldEJsb2NrSGVhZGVyLCBnZXRSYXdUcmFuc2FjdGlvbiwgZ2V0VHhPdXRQcm9vZn0gZnJvbSBcIi4vcnBjY2xpZW50LmpzXCIgLy8gVE9ETyBXaHkgaXMgdGhlIC5qcyBleHRlbnNpb24gcmVxdWlyZWQ/XG5pbXBvcnQge1xuICAgIEJ1ZmZlckNWLFxuICAgIGNhbGxSZWFkT25seUZ1bmN0aW9uLFxuICAgIGxpc3RDVixcbiAgICB0dXBsZUNWLFxuICAgIHVpbnRDVixcbiAgICBDbGFyaXR5VmFsdWUsXG4gICAgYnVmZmVyQ1ZGcm9tU3RyaW5nLCBidWZmZXJDViwgY3ZUb1ZhbHVlLFxufSBmcm9tIFwiQHN0YWNrcy90cmFuc2FjdGlvbnNcIlxuaW1wb3J0ICdkb3RlbnYvY29uZmlnJ1xuaW1wb3J0IHtNZXJrbGVUcmVlfSBmcm9tIFwibWVya2xldHJlZWpzXCI7XG5pbXBvcnQgU0hBMjU2IGZyb20gXCJjcnlwdG8tanMvc2hhMjU2LmpzXCJcblxuY29uc3Qge0NMQVJJVFlfQklUQ09JTl9DT05UUkFDVF9OQU1FLCBDTEFSSVRZX0JJVENPSU5fQ09OVFJBQ1RfQUREUkVTU30gPSBwcm9jZXNzLmVudlxuXG5pbnRlcmZhY2UgUHJvdmFibGVUeCB7XG4gICAgdHg6IEJ1ZmZlcixcbiAgICB0eElkOiBzdHJpbmcsXG4gICAgdHhJbmRleDogbnVtYmVyLFxuICAgIGJsb2NrSGVpZ2h0OiBzdHJpbmcsXG4gICAgYmxvY2tIZWFkZXI6IEJ1ZmZlcixcbiAgICB0cmVlRGVwdGg6IG51bWJlcixcbiAgICBwcm9vZjogQnVmZmVyW10sXG59XG5cbmNvbnN0IHR4aWQgPSBcIjVhOTU1ZGJiMmY5NTYwOTg0MWU4MmExZmIyYzkxMzY3MWUxNDhlYjIxYTkyM2M2YjVmZTBlODUzMTRmNjNiYjFcIlxuXG5jb25zdCByZXZlcnNlQnVmZmVyID0gKHNyYzogQnVmZmVyKTogQnVmZmVyID0+IHtcbiAgICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKHNyYy5sZW5ndGgpXG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBzcmMubGVuZ3RoIC0gMTsgaSA8PSBqOyArK2ksIC0taikge1xuICAgICAgICBidWZmZXJbaV0gPSBzcmNbal1cbiAgICAgICAgYnVmZmVyW2pdID0gc3JjW2ldXG4gICAgfVxuICAgIHJldHVybiBidWZmZXJcbn1cblxuY29uc3QgZ2V0VHhQcm9vZiA9IGFzeW5jICh0eElkOiBzdHJpbmcpOiBQcm9taXNlPFByb3ZhYmxlVHg+ID0+IHtcbiAgICBjb25zdCB7IGJsb2NraGFzaCwgaGV4IH0gPSBhd2FpdCBnZXRSYXdUcmFuc2FjdGlvbih0eGlkLCB0cnVlKVxuICAgIGNvbnN0IHR4ID0gQnVmZmVyLmZyb20oaGV4LCAnaGV4JylcbiAgICBjb25zdCBibG9ja0hlYWRlciA9IEJ1ZmZlci5mcm9tKGF3YWl0IGdldEJsb2NrSGVhZGVyKGJsb2NraGFzaCksICdoZXgnKVxuICAgIGNvbnN0IHsgdHg6IHR4SWRzLCBoZWlnaHQ6IGJsb2NrSGVpZ2h0IH0gPSBhd2FpdCBnZXRCbG9jayhibG9ja2hhc2gsIDEpXG4gICAgY29uc3QgdHhJbmRleCA9IHR4SWRzLmZpbmRJbmRleCgoaWQ6IHN0cmluZykgPT4gaWQgPT09IHR4SWQpO1xuICAgIGNvbnN0IHRyZWUgPSBuZXcgTWVya2xlVHJlZSh0eElkcywgU0hBMjU2LCB7IGlzQml0Y29pblRyZWU6IHRydWUgfSk7XG4gICAgY29uc3QgdHJlZURlcHRoID0gdHJlZS5nZXREZXB0aCgpO1xuICAgIGNvbnN0IHByb29mID0gdHJlZS5nZXRQcm9vZih0eElkLCB0eEluZGV4KS5tYXAocCA9PiByZXZlcnNlQnVmZmVyKHAuZGF0YSkpO1xuXG4gICAgcmV0dXJuIHsgdHgsIHR4SWQsIHR4SW5kZXgsIGJsb2NrSGVpZ2h0LCBibG9ja0hlYWRlciwgdHJlZURlcHRoLCBwcm9vZiB9XG59XG5cbmNvbnN0IHZlcmlmeVByb29mT25TdGFja3MgPSBhc3luYyAoeyBibG9ja0hlaWdodCwgYmxvY2tIZWFkZXIsIHR4LCB0eEluZGV4LCBwcm9vZiwgdHJlZURlcHRoIH06IFByb3ZhYmxlVHgpOiBQcm9taXNlPGFueT4gPT4ge1xuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9ICd3YXMtdHgtbWluZWQtY29tcGFjdCdcbiAgICBjb25zdCBmdW5jdGlvbkFyZ3M6IENsYXJpdHlWYWx1ZVtdID0gW1xuICAgICAgICB0dXBsZUNWKHtcbiAgICAgICAgICAgIGhlYWRlcjogYnVmZmVyQ1YoYmxvY2tIZWFkZXIpLFxuICAgICAgICAgICAgaGVpZ2h0OiB1aW50Q1YoYmxvY2tIZWlnaHQpLFxuICAgICAgICB9KSxcbiAgICAgICAgYnVmZmVyQ1YodHgpLFxuICAgICAgICB0dXBsZUNWKHtcbiAgICAgICAgICAgIFwidHgtaW5kZXhcIjogdWludENWKHR4SW5kZXgpLFxuICAgICAgICAgICAgaGFzaGVzOiBsaXN0Q1Y8QnVmZmVyQ1Y+KHByb29mLm1hcChwID0+IGJ1ZmZlckNWKHApKSksXG4gICAgICAgICAgICBcInRyZWUtZGVwdGhcIjogdWludENWKHRyZWVEZXB0aClcbiAgICAgICAgfSlcbiAgICBdXG4gICAgY29uc3QgbmV0d29yayA9ICd0ZXN0bmV0J1xuICAgIGNvbnN0IHNlbmRlckFkZHJlc3MgPSAnU1QyNFlZQVdRNERLNFJLQ0tLMVJQNFBYMFg1U0NTWFRXUVhGR1ZDVlknXG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYWxsUmVhZE9ubHlGdW5jdGlvbih7XG4gICAgICAgIGNvbnRyYWN0TmFtZTogQ0xBUklUWV9CSVRDT0lOX0NPTlRSQUNUX05BTUUgYXMgc3RyaW5nLFxuICAgICAgICBjb250cmFjdEFkZHJlc3M6IENMQVJJVFlfQklUQ09JTl9DT05UUkFDVF9BRERSRVNTIGFzIHN0cmluZyxcbiAgICAgICAgZnVuY3Rpb25OYW1lLFxuICAgICAgICBmdW5jdGlvbkFyZ3MsXG4gICAgICAgIG5ldHdvcmssXG4gICAgICAgIHNlbmRlckFkZHJlc3MsXG4gICAgfSlcbiAgICByZXR1cm4gY3ZUb1ZhbHVlKHJlc3VsdClcbn1cblxuZ2V0VHhQcm9vZih0eGlkKVxuICAgIC50aGVuKHZlcmlmeVByb29mT25TdGFja3MpXG4gICAgLnRoZW4oY29uc29sZS5sb2cpIC8vIEZJWE1FIEV4cGVjdGluZyB0cnVlLCBnZXR0aW5nIGZhbHNlXG4gICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpIl19
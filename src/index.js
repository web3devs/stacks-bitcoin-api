import { getBlock, getBlockHeader, getRawTransaction } from "./rpcclient.js"; // TODO Why is the .js extension required?
import { bufferCV, callReadOnlyFunction, cvToValue, listCV, tupleCV, uintCV, } from "@stacks/transactions";
import 'dotenv/config';
import { MerkleTree } from "merkletreejs";
import SHA256 from "crypto-js/sha256.js";
import { verifyBlockHeader } from "./ClarityBitcoinClient.js";
import { getStxBlockHeight } from "./BlockApiClient.js";
const { CLARITY_BITCOIN_CONTRACT_NAME, CLARITY_BITCOIN_CONTRACT_ADDRESS, NETWORK, SENDER_ADDRESS } = process.env;
const txid = "20f85e35d02e28ac89db8764e280db560de1baaa3ce66f15dcea349fb137879c";
const reverseBuffer = (src) => {
    var buffer = Buffer.alloc(src.length);
    for (var i = 0, j = src.length - 1; i <= j; ++i, --j) {
        buffer[i] = src[j];
        buffer[j] = src[i];
    }
    return buffer;
};
const getTxProof = async (txId) => {
    // TODO Make this work for segwit txs
    // console.log(await getRawTransaction(txid, true))
    const { blockhash, hex } = await getRawTransaction(txid, true);
    const tx = Buffer.from(hex, 'hex');
    // console.log(tx.length)
    const blockHeader = Buffer.from(await getBlockHeader(blockhash), 'hex');
    // console.log(reverseBuffer(blockHeader.subarray(36, 68)).toString('hex'))
    const { tx: txIds, height } = await getBlock(blockhash, 1);
    const stxBlockHeight = await getStxBlockHeight(height);
    const txIndex = txIds.findIndex((id) => id === txId);
    const tree = new MerkleTree(txIds, SHA256, { isBitcoinTree: true });
    // console.log(tree.toString())
    const treeDepth = tree.getDepth();
    const proof = tree.getProof(txId, txIndex).map(p => p.data);
    console.assert(proof.length === treeDepth, "treeDepth and proof don't match");
    return { tx, txId, txIndex, stxBlockHeight, blockHeader, proof };
};
const getBlockHeaderHash = async (blockHeight) => {
    // (get-bc-h-hash (bh uint))
    const functionName = 'get-bc-h-hash';
    const functionArgs = [
        uintCV(58225)
    ];
    const result = await callReadOnlyFunction({
        contractName: CLARITY_BITCOIN_CONTRACT_NAME,
        contractAddress: CLARITY_BITCOIN_CONTRACT_ADDRESS,
        functionName,
        functionArgs,
        network: NETWORK,
        senderAddress: SENDER_ADDRESS,
    });
    return cvToValue(result);
};
const getReversedTxId = async ({ tx, txId }) => {
    // (define-read-only (get-reversed-txid (tx (buff 1024)))
    const functionName = 'get-reversed-txid';
    const functionArgs = [
        bufferCV(tx)
    ];
    const result = await callReadOnlyFunction({
        contractName: CLARITY_BITCOIN_CONTRACT_NAME,
        contractAddress: CLARITY_BITCOIN_CONTRACT_ADDRESS,
        functionName,
        functionArgs,
        network: NETWORK,
        senderAddress: SENDER_ADDRESS,
    });
    console.assert(reverseBuffer(Buffer.from(txId, 'hex')).toString('hex') === cvToValue(result), txId);
    return cvToValue(result);
};
const verifyProofOnStacks = async ({ stxBlockHeight, blockHeader, tx, txIndex, proof }) => {
    console.assert(blockHeader.length === 80, "header length incorrect");
    console.assert(tx.length <= 1024, "tx too long");
    // console.log(proof.map(p => p.toString('hex')))
    // console.log(txIndex)
    const functionName = 'was-tx-mined-compact';
    const functionArgs = [
        tupleCV({
            header: bufferCV(blockHeader),
            height: uintCV(stxBlockHeight),
        }),
        bufferCV(tx),
        tupleCV({
            "tx-index": uintCV(txIndex),
            hashes: listCV(proof.map(hash => bufferCV(reverseBuffer(hash)))),
            "tree-depth": uintCV(proof.length)
        })
    ];
    const result = await callReadOnlyFunction({
        contractName: CLARITY_BITCOIN_CONTRACT_NAME,
        contractAddress: CLARITY_BITCOIN_CONTRACT_ADDRESS,
        functionName,
        functionArgs,
        network: NETWORK,
        senderAddress: SENDER_ADDRESS,
    });
    return cvToValue(result).value;
};
getTxProof(txid)
    // .then(getBlockHeaderHash)
    .then(({ blockHeader, stxBlockHeight }) => verifyBlockHeader(blockHeader, stxBlockHeight))
    // .then(verifyProofOnStacks)
    // .then(getReversedTxId)
    .then(console.log)
    .catch(console.error);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsUUFBUSxFQUFFLGNBQWMsRUFBRSxpQkFBaUIsRUFBQyxNQUFNLGdCQUFnQixDQUFBLENBQUMsMENBQTBDO0FBQ3JILE9BQU8sRUFFSCxRQUFRLEVBQ1Isb0JBQW9CLEVBRXBCLFNBQVMsRUFDVCxNQUFNLEVBQ04sT0FBTyxFQUNQLE1BQU0sR0FDVCxNQUFNLHNCQUFzQixDQUFBO0FBQzdCLE9BQU8sZUFBZSxDQUFBO0FBQ3RCLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxjQUFjLENBQUE7QUFDdkMsT0FBTyxNQUFNLE1BQU0scUJBQXFCLENBQUE7QUFDeEMsT0FBTyxFQUFDLGlCQUFpQixFQUFDLE1BQU0sMkJBQTJCLENBQUE7QUFDM0QsT0FBTyxFQUFDLGlCQUFpQixFQUFDLE1BQU0scUJBQXFCLENBQUE7QUFFckQsTUFBTSxFQUNGLDZCQUE2QixFQUM3QixnQ0FBZ0MsRUFDaEMsT0FBTyxFQUNQLGNBQWMsRUFDakIsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFBO0FBV2YsTUFBTSxJQUFJLEdBQUcsa0VBQWtFLENBQUE7QUFFL0UsTUFBTSxhQUFhLEdBQUcsQ0FBQyxHQUFXLEVBQVUsRUFBRTtJQUMxQyxJQUFJLE1BQU0sR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQTtJQUNyQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRTtRQUNsRCxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFBO1FBQ2xCLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMs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QUNyRCxlQUFlLEVBQUUsZ0NBQTBDO1FBQzNELFlBQVk7UUFDWixZQUFZO1FBQ1osT0FBTyxFQUFFLE9BQWM7UUFDdkIsYUFBYSxFQUFFLGNBQXdCO0tBQzFDLENBQUMsQ0FBQTtJQUNGLE9BQU8sU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssQ0FBQTtBQUNsQyxDQUFDLENBQUE7QUFFRCxVQUFVLENBQUMsSUFBSSxDQUFDO0lBQ1osNEJBQTRCO0tBQzNCLElBQUksQ0FBQyxDQUFDLEVBQUMsV0FBVyxFQUFFLGNBQWMsRUFBYSxFQUFvQixFQUFFLENBQ2xFLGlCQUFpQixDQUFDLFdBQVcsRUFBRSxjQUFjLENBQUMsQ0FBQztJQUNuRCw2QkFBNkI7SUFDN0IseUJBQXlCO0tBQ3hCLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO0tBQ2pCLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2dldEJsb2NrLCBnZXRCbG9ja0hlYWRlciwgZ2V0UmF3VHJhbnNhY3Rpb259IGZyb20gXCIuL3JwY2NsaWVudC5qc1wiIC8vIFRPRE8gV2h5IGlzIHRoZSAuanMgZXh0ZW5zaW9uIHJlcXVpcmVkP1xuaW1wb3J0IHtcbiAgICBCdWZmZXJDVixcbiAgICBidWZmZXJDVixcbiAgICBjYWxsUmVhZE9ubHlGdW5jdGlvbixcbiAgICBDbGFyaXR5VmFsdWUsXG4gICAgY3ZUb1ZhbHVlLFxuICAgIGxpc3RDVixcbiAgICB0dXBsZUNWLFxuICAgIHVpbnRDVixcbn0gZnJvbSBcIkBzdGFja3MvdHJhbnNhY3Rpb25zXCJcbmltcG9ydCAnZG90ZW52L2NvbmZpZydcbmltcG9ydCB7TWVya2xlVHJlZX0gZnJvbSBcIm1lcmtsZXRyZWVqc1wiXG5pbXBvcnQgU0hBMjU2IGZyb20gXCJjcnlwdG8tanMvc2hhMjU2LmpzXCJcbmltcG9ydCB7dmVyaWZ5QmxvY2tIZWFkZXJ9IGZyb20gXCIuL0NsYXJpdHlCaXRjb2luQ2xpZW50LmpzXCJcbmltcG9ydCB7Z2V0U3R4QmxvY2tIZWlnaHR9IGZyb20gXCIuL0Jsb2NrQXBpQ2xpZW50LmpzXCJcblxuY29uc3Qge1xuICAgIENMQVJJVFlfQklUQ09JTl9DT05UUkFDVF9OQU1FLFxuICAgIENMQVJJVFlfQklUQ09JTl9DT05UUkFDVF9BRERSRVNTLFxuICAgIE5FVFdPUkssXG4gICAgU0VOREVSX0FERFJFU1Ncbn0gPSBwcm9jZXNzLmVudlxuXG5pbnRlcmZhY2UgUHJvdmFibGVUeCB7XG4gICAgdHg6IEJ1ZmZlcixcbiAgICB0eElkOiBzdHJpbmcsXG4gICAgdHhJbmRleDogbnVtYmVyLFxuICAgIHN0eEJsb2NrSGVpZ2h0OiBudW1iZXIsXG4gICAgYmxvY2tIZWFkZXI6IEJ1ZmZlcixcbiAgICBwcm9vZjogQnVmZmVyW10sXG59XG5cbmNvbnN0IHR4aWQgPSBcIjIwZjg1ZTM1ZDAyZTI4YWM4OWRiODc2NGUyODBkYjU2MGRlMWJhYWEzY2U2NmYxNWRjZWEzNDlmYjEzNzg3OWNcIlxuXG5jb25zdCByZXZlcnNlQnVmZmVyID0gKHNyYzogQnVmZmVyKTogQnVmZmVyID0+IHtcbiAgICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKHNyYy5sZW5ndGgpXG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBzcmMubGVuZ3RoIC0gMTsgaSA8PSBqOyArK2ksIC0taikge1xuICAgICAgICBidWZmZXJbaV0gPSBzcmNbal1cbiAgICAgICAgYnVmZmVyW2pdID0gc3JjW2ldXG4gICAgfVxuICAgIHJldHVybiBidWZmZXJcbn1cblxuY29uc3QgZ2V0VHhQcm9vZiA9IGFzeW5jICh0eElkOiBzdHJpbmcpOiBQcm9taXNlPFByb3ZhYmxlVHg+ID0+IHtcbiAgICAvLyBUT0RPIE1ha2UgdGhpcyB3b3JrIGZvciBzZWd3aXQgdHhzXG4gICAgLy8gY29uc29sZS5sb2coYXdhaXQgZ2V0UmF3VHJhbnNhY3Rpb24odHhpZCwgdHJ1ZSkpXG4gICAgY29uc3QgeyBibG9ja2hhc2gsIGhleCB9ID0gYXdhaXQgZ2V0UmF3VHJhbnNhY3Rpb24odHhpZCwgdHJ1ZSlcbiAgICBjb25zdCB0eCA9IEJ1ZmZlci5mcm9tKGhleCwgJ2hleCcpXG4gICAgLy8gY29uc29sZS5sb2codHgubGVuZ3RoKVxuICAgIGNvbnN0IGJsb2NrSGVhZGVyID0gQnVmZmVyLmZyb20oYXdhaXQgZ2V0QmxvY2tIZWFkZXIoYmxvY2toYXNoKSwgJ2hleCcpXG4gICAgLy8gY29uc29sZS5sb2cocmV2ZXJzZUJ1ZmZlcihibG9ja0hlYWRlci5zdWJhcnJheSgzNiwgNjgpKS50b1N0cmluZygnaGV4JykpXG4gICAgY29uc3QgeyB0eDogdHhJZHMsIGhlaWdodCB9ID0gYXdhaXQgZ2V0QmxvY2soYmxvY2toYXNoLCAxKVxuICAgIGNvbnN0IHN0eEJsb2NrSGVpZ2h0ID0gYXdhaXQgZ2V0U3R4QmxvY2tIZWlnaHQoaGVpZ2h0KSBhcyBudW1iZXJcbiAgICBjb25zdCB0eEluZGV4ID0gdHhJZHMuZmluZEluZGV4KChpZDogc3RyaW5nKSA9PiBpZCA9PT0gdHhJZCk7XG4gICAgY29uc3QgdHJlZSA9IG5ldyBNZXJrbGVUcmVlKHR4SWRzLCBTSEEyNTYsIHsgaXNCaXRjb2luVHJlZTogdHJ1ZSB9KTtcbiAgICAvLyBjb25zb2xlLmxvZyh0cmVlLnRvU3RyaW5nKCkpXG4gICAgY29uc3QgdHJlZURlcHRoID0gdHJlZS5nZXREZXB0aCgpO1xuICAgIGNvbnN0IHByb29mID0gdHJlZS5nZXRQcm9vZih0eElkLCB0eEluZGV4KS5tYXAocCA9PiBwLmRhdGEpO1xuXG4gICAgY29uc29sZS5hc3NlcnQocHJvb2YubGVuZ3RoID09PSB0cmVlRGVwdGgsIFwidHJlZURlcHRoIGFuZCBwcm9vZiBkb24ndCBtYXRjaFwiKVxuXG4gICAgcmV0dXJuIHsgdHgsIHR4SWQsIHR4SW5kZXgsIHN0eEJsb2NrSGVpZ2h0LCBibG9ja0hlYWRlciwgcHJvb2YgfVxufVxuXG5cbmNvbnN0IGdldEJsb2NrSGVhZGVySGFzaCA9IGFzeW5jIChibG9ja0hlaWdodDogbnVtYmVyKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICAvLyAoZ2V0LWJjLWgtaGFzaCAoYmggdWludCkpXG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gJ2dldC1iYy1oLWhhc2gnXG4gICAgY29uc3QgZnVuY3Rpb25BcmdzOiBDbGFyaXR5VmFsdWVbXSA9IFtcbiAgICAgICAgdWludENWKDU4MjI1KVxuICAgIF1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhbGxSZWFkT25seUZ1bmN0aW9uKHtcbiAgICAgICAgY29udHJhY3ROYW1lOiBDTEFSSVRZX0JJVENPSU5fQ09OVFJBQ1RfTkFNRSBhcyBzdHJpbmcsXG4gICAgICAgIGNvbnRyYWN0QWRkcmVzczogQ0xBUklUWV9CSVRDT0lOX0NPTlRSQUNUX0FERFJFU1MgYXMgc3RyaW5nLFxuICAgICAgICBmdW5jdGlvbk5hbWUsXG4gICAgICAgIGZ1bmN0aW9uQXJncyxcbiAgICAgICAgbmV0d29yazogTkVUV09SSyBhcyBhbnksXG4gICAgICAgIHNlbmRlckFkZHJlc3M6IFNFTkRFUl9BRERSRVNTIGFzIHN0cmluZyxcbiAgICB9KVxuICAgIHJldHVybiBjdlRvVmFsdWUocmVzdWx0KVxuXG59XG5cbmNvbnN0IGdldFJldmVyc2VkVHhJZCA9IGFzeW5jICh7dHgsIHR4SWR9OiBQcm92YWJsZVR4KTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICAvLyAoZGVmaW5lLXJlYWQtb25seSAoZ2V0LXJldmVyc2VkLXR4aWQgKHR4IChidWZmIDEwMjQpKSlcbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSAnZ2V0LXJldmVyc2VkLXR4aWQnXG4gICAgY29uc3QgZnVuY3Rpb25BcmdzOiBDbGFyaXR5VmFsdWVbXSA9IFtcbiAgICAgICAgYnVmZmVyQ1YodHgpXG4gICAgXVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FsbFJlYWRPbmx5RnVuY3Rpb24oe1xuICAgICAgICBjb250cmFjdE5hbWU6IENMQVJJVFlfQklUQ09JTl9DT05UUkFDVF9OQU1FIGFzIHN0cmluZyxcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiBDTEFSSVRZX0JJVENPSU5fQ09OVFJBQ1RfQUREUkVTUyBhcyBzdHJpbmcsXG4gICAgICAgIGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgZnVuY3Rpb25BcmdzLFxuICAgICAgICBuZXR3b3JrOiBORVRXT1JLIGFzIGFueSxcbiAgICAgICAgc2VuZGVyQWRkcmVzczogU0VOREVSX0FERFJFU1MgYXMgc3RyaW5nLFxuICAgIH0pXG4gICAgY29uc29sZS5hc3NlcnQocmV2ZXJzZUJ1ZmZlcihCdWZmZXIuZnJvbSh0eElkLCAnaGV4JykpLnRvU3RyaW5nKCdoZXgnKSA9PT0gY3ZUb1ZhbHVlKHJlc3VsdCksIHR4SWQpXG4gICAgcmV0dXJuIGN2VG9WYWx1ZShyZXN1bHQpXG59XG5cbmNvbnN0IHZlcmlmeVByb29mT25TdGFja3MgPSBhc3luYyAoeyBzdHhCbG9ja0hlaWdodCwgYmxvY2tIZWFkZXIsIHR4LCB0eEluZGV4LCBwcm9vZiB9OiBQcm92YWJsZVR4KTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgY29uc29sZS5hc3NlcnQoYmxvY2tIZWFkZXIubGVuZ3RoID09PSA4MCwgXCJoZWFkZXIgbGVuZ3RoIGluY29ycmVjdFwiKVxuICAgIGNvbnNvbGUuYXNzZXJ0KHR4Lmxlbmd0aCA8PSAxMDI0LCBcInR4IHRvbyBsb25nXCIpXG4gICAgLy8gY29uc29sZS5sb2cocHJvb2YubWFwKHAgPT4gcC50b1N0cmluZygnaGV4JykpKVxuICAgIC8vIGNvbnNvbGUubG9nKHR4SW5kZXgpXG5cbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSAnd2FzLXR4LW1pbmVkLWNvbXBhY3QnXG4gICAgY29uc3QgZnVuY3Rpb25BcmdzOiBDbGFyaXR5VmFsdWVbXSA9IFtcbiAgICAgICAgdHVwbGVDVih7XG4gICAgICAgICAgICBoZWFkZXI6IGJ1ZmZlckNWKGJsb2NrSGVhZGVyKSxcbiAgICAgICAgICAgIGhlaWdodDogdWludENWKHN0eEJsb2NrSGVpZ2h0KSxcbiAgICAgICAgfSksXG4gICAgICAgIGJ1ZmZlckNWKHR4KSxcbiAgICAgICAgdHVwbGVDVih7XG4gICAgICAgICAgICBcInR4LWluZGV4XCI6IHVpbnRDVih0eEluZGV4KSxcbiAgICAgICAgICAgIGhhc2hlczogbGlzdENWPEJ1ZmZlckNWPihwcm9vZi5tYXAoaGFzaCA9PiBidWZmZXJDVihyZXZlcnNlQnVmZmVyKGhhc2gpKSkpLFxuICAgICAgICAgICAgXCJ0cmVlLWRlcHRoXCI6IHVpbnRDVihwcm9vZi5sZW5ndGgpXG4gICAgICAgIH0pXG4gICAgXVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhbGxSZWFkT25seUZ1bmN0aW9uKHtcbiAgICAgICAgY29udHJhY3ROYW1lOiBDTEFSSVRZX0JJVENPSU5fQ09OVFJBQ1RfTkFNRSBhcyBzdHJpbmcsXG4gICAgICAgIGNvbnRyYWN0QWRkcmVzczogQ0xBUklUWV9CSVRDT0lOX0NPTlRSQUNUX0FERFJFU1MgYXMgc3RyaW5nLFxuICAgICAgICBmdW5jdGlvbk5hbWUsXG4gICAgICAgIGZ1bmN0aW9uQXJncyxcbiAgICAgICAgbmV0d29yazogTkVUV09SSyBhcyBhbnksXG4gICAgICAgIHNlbmRlckFkZHJlc3M6IFNFTkRFUl9BRERSRVNTIGFzIHN0cmluZyxcbiAgICB9KVxuICAgIHJldHVybiBjdlRvVmFsdWUocmVzdWx0KS52YWx1ZVxufVxuXG5nZXRUeFByb29mKHR4aWQpXG4gICAgLy8gLnRoZW4oZ2V0QmxvY2tIZWFkZXJIYXNoKVxuICAgIC50aGVuKCh7YmxvY2tIZWFkZXIsIHN0eEJsb2NrSGVpZ2h0fTogUHJvdmFibGVUeCk6IFByb21pc2U8Ym9vbGVhbj4gPT5cbiAgICAgICAgdmVyaWZ5QmxvY2tIZWFkZXIoYmxvY2tIZWFkZXIsIHN0eEJsb2NrSGVpZ2h0KSlcbiAgICAvLyAudGhlbih2ZXJpZnlQcm9vZk9uU3RhY2tzKVxuICAgIC8vIC50aGVuKGdldFJldmVyc2VkVHhJZClcbiAgICAudGhlbihjb25zb2xlLmxvZylcbiAgICAuY2F0Y2goY29uc29sZS5lcnJvcikiXX0=
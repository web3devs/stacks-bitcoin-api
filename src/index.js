import { getBlockStats, getRawBlockHeader, getTransactionDetails } from "./BitcoinRpcClient.js"; // TODO Why is the .js extension required?
import 'dotenv/config';
import { MerkleTree } from "merkletreejs";
import SHA256 from "crypto-js/sha256.js";
import { getStxBlockHeight } from "./BlockApiClient.js";
import { cvToBuffer, hexOrBufferToBuffer, hexOrBufferToHex, numberToBuffer, reverseBuffer } from "./utils.js";
import { verifyCompactTx, verifyTx, concatHeader } from "./ClarityBitcoinClient.js";
import { bufferCV, cvToValue, getCVTypeString, listCV, tupleCV, uintCV } from "@stacks/transactions";
const { CLARITY_BITCOIN_CONTRACT_NAME, CLARITY_BITCOIN_CONTRACT_ADDRESS, NETWORK, SENDER_ADDRESS } = process.env;
// const txid = "4a992428186ef340c1137509c484f55793afe6a091dc1ae40169794a4b68a52c"
const txid = "20f85e35d02e28ac89db8764e280db560de1baaa3ce66f15dcea349fb137879c";
// const txid = "4204768f4e125d97d36cf7769adea9140fa28e359ad4d9757e8d8f86cd152050"
const getTxProof = async (txId) => {
    // TODO Make this work for segwit txs
    // TODO add handling of unknown transaction errors
    const txIdHex = hexOrBufferToHex(txId);
    const txDetail = await getTransactionDetails(txIdHex);
    const blockHeader = Buffer.from(await getRawBlockHeader(txDetail.blockhash), 'hex');
    const blockDetail = await getBlockStats(txDetail.blockhash);
    const stxBlockHeight = await getStxBlockHeight(blockDetail.height);
    const txIndex = blockDetail.tx.findIndex((id) => id === txId);
    const tree = new MerkleTree(blockDetail.tx, SHA256, { isBitcoinTree: true });
    const proof = tree.getProof(blockDetail.tx, txIndex).map(p => p.data);
    return {
        tx: Buffer.from(txDetail.hex, "hex"),
        txId: hexOrBufferToBuffer(txId),
        txIndex,
        stxBlockHeight,
        blockHeader,
        proof,
        txDetail,
        blockDetail
    };
};
export const toCompactProofCV = async ({ tx, txIndex, proof, blockHeader, stxBlockHeight }) => {
    return {
        compactHeader: tupleCV({
            header: bufferCV(blockHeader),
            height: uintCV(stxBlockHeight)
        }),
        tx: bufferCV(tx),
        proof: tupleCV({
            "tx-index": uintCV(txIndex),
            hashes: listCV(proof.map(p => bufferCV(reverseBuffer(p)))),
            "tree-depth": uintCV(proof.length)
        }),
    };
};
export const toProofCV = async ({ tx, txIndex, proof, stxBlockHeight, blockDetail: { versionHex, previousblockhash, merkleroot, time, bits, nonce } }) => {
    return {
        header: tupleCV({
            version: bufferCV(reverseBuffer(Buffer.from(versionHex, 'hex'))),
            parent: bufferCV(reverseBuffer(Buffer.from(previousblockhash, 'hex'))),
            'merkle-root': bufferCV(reverseBuffer(Buffer.from(merkleroot, 'hex'))),
            timestamp: bufferCV(numberToBuffer(time, 4)),
            nbits: bufferCV(reverseBuffer(Buffer.from(bits, 'hex'))),
            nonce: bufferCV(numberToBuffer(nonce, 4)),
            height: uintCV(stxBlockHeight)
        }),
        tx: bufferCV(tx),
        proof: tupleCV({
            "tx-index": uintCV(txIndex),
            hashes: listCV(proof.map(p => bufferCV(reverseBuffer(p)))),
            "tree-depth": uintCV(proof.length)
        }),
    };
};
const proofPromise = getTxProof(txid);
proofPromise
    .then(toCompactProofCV)
    .then(({ compactHeader, tx, proof }) => verifyCompactTx(compactHeader, tx, proof))
    .then(result => cvToValue(result)?.value)
    .then(r => console.log('verifyCompactTx result:', r))
    .catch(e => {
    throw e;
});
proofPromise
    .then(toProofCV)
    .then(({ header }) => concatHeader(header))
    .then(result => getCVTypeString(result) === '(buff 80)' ? cvToBuffer(result).toString('hex') : result)
    .then(console.log)
    .catch(console.error);
proofPromise
    .then(toProofCV)
    .then(async ({ header, tx, proof }) => verifyTx(header, tx, proof))
    .then(result => cvToValue(result)?.value)
    .then(r => console.log('verifyTx Result:', r))
    .catch(e => console.error(e));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsYUFBYSxFQUFFLGlCQUFpQixFQUFFLHFCQUFxQixFQUFDLE1BQU0sdUJBQXVCLENBQUEsQ0FBQywwQ0FBMEM7QUFDeEksT0FBTyxlQUFlLENBQUE7QUFDdEIsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLGNBQWMsQ0FBQTtBQUN2QyxPQUFPLE1BQU0sTUFBTSxxQkFBcUIsQ0FBQTtBQUN4QyxPQUFPLEVBQUMsaUJBQWlCLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQTtBQUdyRCxPQUFPLEVBQUMsVUFBVSxFQUFFLG1CQUFtQixFQUFFLGdCQUFnQixFQUFFLGNBQWMsRUFBRSxhQUFhLEVBQUMsTUFBTSxZQUFZLENBQUM7QUFDNUcsT0FBTyxFQUFDLGVBQWUsRUFBRSxRQUFRLEVBQUUsWUFBWSxFQUFDLE1BQU0sMkJBQTJCLENBQUM7QUFDbEYsT0FBTyxFQUVILFFBQVEsRUFDUixTQUFTLEVBQ1QsZUFBZSxFQUVmLE1BQU0sRUFDTixPQUFPLEVBQ1AsTUFBTSxFQUNULE1BQU0sc0JBQXNCLENBQUM7QUFHOUIsTUFBTSxFQUNGLDZCQUE2QixFQUM3QixnQ0FBZ0MsRUFDaEMsT0FBTyxFQUNQLGNBQWMsRUFDakIsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFBO0FBYWYsa0ZBQWtGO0FBQ2xGLE1BQU0sSUFBSSxHQUFHLGtFQUFrRSxDQUFBO0FBQy9FLGtGQUFrRjtBQUVsRixNQUFNLFVBQVUsR0FBRyxLQUFLLEVBQUUsSUFBcUIsRUFBdUIsRUFBRTtJQUNwRSxxQ0FBcUM7SUFDckMsa0RBQWtEO0lBQ2xELE1BQU0sT0FBTyxHQUFHLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFBO0lBQ3RDLE1BQU0sUUFBUSxHQUFHLE1BQU0scUJBQXFCLENBQUMsT0FBTyxDQUFDLENBQUE7SUFDckQsTUFBTSxXQUFXLEdBQUcsTUFBTSxD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Q1AsSUFBSSxDQUFDLFNBQVMsQ0FBQztLQUNmLElBQUksQ0FBQyxDQUFDLEVBQUMsTUFBTSxFQUFDLEVBQUUsRUFBRSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUN4QyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FDWCxlQUFlLENBQUMsTUFBTSxDQUFDLEtBQUssV0FBVyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsTUFBa0IsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUNwRztLQUNBLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO0tBQ2pCLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUE7QUFFekIsWUFBWTtLQUNQLElBQUksQ0FBQyxTQUFTLENBQUM7S0FDZixJQUFJLENBQUMsS0FBSyxFQUFFLEVBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUMsRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7S0FDaEUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEtBQUssQ0FBQztLQUN4QyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLGtCQUFrQixFQUFFLENBQUMsQ0FBQyxDQUFDO0tBQzdDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Z2V0QmxvY2tTdGF0cywgZ2V0UmF3QmxvY2tIZWFkZXIsIGdldFRyYW5zYWN0aW9uRGV0YWlsc30gZnJvbSBcIi4vQml0Y29pblJwY0NsaWVudC5qc1wiIC8vIFRPRE8gV2h5IGlzIHRoZSAuanMgZXh0ZW5zaW9uIHJlcXVpcmVkP1xuaW1wb3J0ICdkb3RlbnYvY29uZmlnJ1xuaW1wb3J0IHtNZXJrbGVUcmVlfSBmcm9tIFwibWVya2xldHJlZWpzXCJcbmltcG9ydCBTSEEyNTYgZnJvbSBcImNyeXB0by1qcy9zaGEyNTYuanNcIlxuaW1wb3J0IHtnZXRTdHhCbG9ja0hlaWdodH0gZnJvbSBcIi4vQmxvY2tBcGlDbGllbnQuanNcIlxuaW1wb3J0IEJpZ051bWJlciBmcm9tICdCaWdOdW1iZXIuanMnXG5pbXBvcnQgQk4gZnJvbSBcImJuLmpzXCI7XG5pbXBvcnQge2N2VG9CdWZmZXIsIGhleE9yQnVmZmVyVG9CdWZmZXIsIGhleE9yQnVmZmVyVG9IZXgsIG51bWJlclRvQnVmZmVyLCByZXZlcnNlQnVmZmVyfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuaW1wb3J0IHt2ZXJpZnlDb21wYWN0VHgsIHZlcmlmeVR4LCBjb25jYXRIZWFkZXJ9IGZyb20gXCIuL0NsYXJpdHlCaXRjb2luQ2xpZW50LmpzXCI7XG5pbXBvcnQge1xuICAgIEJ1ZmZlckNWLFxuICAgIGJ1ZmZlckNWLFxuICAgIGN2VG9WYWx1ZSxcbiAgICBnZXRDVlR5cGVTdHJpbmcsXG4gICAgZ2V0VHlwZVN0cmluZyxcbiAgICBsaXN0Q1YsXG4gICAgdHVwbGVDVixcbiAgICB1aW50Q1Zcbn0gZnJvbSBcIkBzdGFja3MvdHJhbnNhY3Rpb25zXCI7XG5pbXBvcnQge0NsYXJpdHlWYWx1ZX0gZnJvbSBcIkBzdGFja3MvdHJhbnNhY3Rpb25zL2Rpc3QvY2xhcml0eVwiO1xuXG5jb25zdCB7XG4gICAgQ0xBUklUWV9CSVRDT0lOX0NPTlRSQUNUX05BTUUsXG4gICAgQ0xBUklUWV9CSVRDT0lOX0NPTlRSQUNUX0FERFJFU1MsXG4gICAgTkVUV09SSyxcbiAgICBTRU5ERVJfQUREUkVTU1xufSA9IHByb2Nlc3MuZW52XG5cbmludGVyZmFjZSBQcm92YWJsZVR4IHtcbiAgICB0eDogQnVmZmVyLFxuICAgIHR4SWQ6IEJ1ZmZlcixcbiAgICB0eEluZGV4OiBudW1iZXIsXG4gICAgc3R4QmxvY2tIZWlnaHQ6IG51bWJlcixcbiAgICBibG9ja0hlYWRlcjogQnVmZmVyLFxuICAgIHByb29mOiBCdWZmZXJbXSxcbiAgICB0eERldGFpbDogYW55LFxuICAgIGJsb2NrRGV0YWlsOiBhbnksXG59XG5cbi8vIGNvbnN0IHR4aWQgPSBcIjRhOTkyNDI4MTg2ZWYzNDBjMTEzNzUwOWM0ODRmNTU3OTNhZmU2YTA5MWRjMWFlNDAxNjk3OTRhNGI2OGE1MmNcIlxuY29uc3QgdHhpZCA9IFwiMjBmODVlMzVkMDJlMjhhYzg5ZGI4NzY0ZTI4MGRiNTYwZGUxYmFhYTNjZTY2ZjE1ZGNlYTM0OWZiMTM3ODc5Y1wiXG4vLyBjb25zdCB0eGlkID0gXCI0MjA0NzY4ZjRlMTI1ZDk3ZDM2Y2Y3NzY5YWRlYTkxNDBmYTI4ZTM1OWFkNGQ5NzU3ZThkOGY4NmNkMTUyMDUwXCJcblxuY29uc3QgZ2V0VHhQcm9vZiA9IGFzeW5jICh0eElkOiBzdHJpbmcgfCBCdWZmZXIpOiBQcm9taXNlPFByb3ZhYmxlVHg+ID0+IHtcbiAgICAvLyBUT0RPIE1ha2UgdGhpcyB3b3JrIGZvciBzZWd3aXQgdHhzXG4gICAgLy8gVE9ETyBhZGQgaGFuZGxpbmcgb2YgdW5rbm93biB0cmFuc2FjdGlvbiBlcnJvcnNcbiAgICBjb25zdCB0eElkSGV4ID0gaGV4T3JCdWZmZXJUb0hleCh0eElkKVxuICAgIGNvbnN0IHR4RGV0YWlsID0gYXdhaXQgZ2V0VHJhbnNhY3Rpb25EZXRhaWxzKHR4SWRIZXgpXG4gICAgY29uc3QgYmxvY2tIZWFkZXIgPSBCdWZmZXIuZnJvbShhd2FpdCBnZXRSYXdCbG9ja0hlYWRlcih0eERldGFpbC5ibG9ja2hhc2gpLCAnaGV4JylcbiAgICBjb25zdCBibG9ja0RldGFpbCA9IGF3YWl0IGdldEJsb2NrU3RhdHModHhEZXRhaWwuYmxvY2toYXNoKVxuICAgIGNvbnN0IHN0eEJsb2NrSGVpZ2h0ID0gYXdhaXQgZ2V0U3R4QmxvY2tIZWlnaHQoYmxvY2tEZXRhaWwuaGVpZ2h0KSBhcyBudW1iZXJcbiAgICBjb25zdCB0eEluZGV4ID0gYmxvY2tEZXRhaWwudHguZmluZEluZGV4KChpZDogc3RyaW5nKSA9PiBpZCA9PT0gdHhJZClcbiAgICBjb25zdCB0cmVlID0gbmV3IE1lcmtsZVRyZWUoYmxvY2tEZXRhaWwudHgsIFNIQTI1Niwge2lzQml0Y29pblRyZWU6IHRydWV9KVxuICAgIGNvbnN0IHByb29mID0gdHJlZS5nZXRQcm9vZihibG9ja0RldGFpbC50eCwgdHhJbmRleCkubWFwKHAgPT4gcC5kYXRhKVxuICAgIHJldHVybiB7XG4gICAgICAgIHR4OiBCdWZmZXIuZnJvbSh0eERldGFpbC5oZXgsIFwiaGV4XCIpLFxuICAgICAgICB0eElkOiBoZXhPckJ1ZmZlclRvQnVmZmVyKHR4SWQpLFxuICAgICAgICB0eEluZGV4LFxuICAgICAgICBzdHhCbG9ja0hlaWdodCxcbiAgICAgICAgYmxvY2tIZWFkZXIsXG4gICAgICAgIHByb29mLFxuICAgICAgICB0eERldGFpbCxcbiAgICAgICAgYmxvY2tEZXRhaWxcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCB0b0NvbXBhY3RQcm9vZkNWID0gYXN5bmMgKFxuICAgIHtcbiAgICAgICAgdHgsXG4gICAgICAgIHR4SW5kZXgsXG4gICAgICAgIHByb29mLFxuICAgICAgICBibG9ja0hlYWRlcixcbiAgICAgICAgc3R4QmxvY2tIZWlnaHRcbiAgICB9OiBQcm92YWJsZVR4KTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb21wYWN0SGVhZGVyOiB0dXBsZUNWKHtcbiAgICAgICAgICAgIGhlYWRlcjogYnVmZmVyQ1YoYmxvY2tIZWFkZXIpLFxuICAgICAgICAgICAgaGVpZ2h0OiB1aW50Q1Yoc3R4QmxvY2tIZWlnaHQpXG4gICAgICAgIH0pLFxuICAgICAgICB0eDogYnVmZmVyQ1YodHgpLFxuICAgICAgICBwcm9vZjogdHVwbGVDVih7XG4gICAgICAgICAgICBcInR4LWluZGV4XCI6IHVpbnRDVih0eEluZGV4KSxcbiAgICAgICAgICAgIGhhc2hlczogbGlzdENWPEJ1ZmZlckNWPihwcm9vZi5tYXAocCA9PiBidWZmZXJDVihyZXZlcnNlQnVmZmVyKHApKSkpLFxuICAgICAgICAgICAgXCJ0cmVlLWRlcHRoXCI6IHVpbnRDVihwcm9vZi5sZW5ndGgpXG4gICAgICAgIH0pLFxuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IHRvUHJvb2ZDViA9IGFzeW5jIChcbiAgICB7XG4gICAgICAgIHR4LFxuICAgICAgICB0eEluZGV4LFxuICAgICAgICBwcm9vZixcbiAgICAgICAgc3R4QmxvY2tIZWlnaHQsXG4gICAgICAgIGJsb2NrRGV0YWlsOiB7XG4gICAgICAgICAgICB2ZXJzaW9uSGV4LFxuICAgICAgICAgICAgcHJldmlvdXNibG9ja2hhc2gsXG4gICAgICAgICAgICBtZXJrbGVyb290LFxuICAgICAgICAgICAgdGltZSxcbiAgICAgICAgICAgIGJpdHMsXG4gICAgICAgICAgICBub25jZVxuICAgICAgICB9XG4gICAgfTogUHJvdmFibGVUeCk6IFByb21pc2U8YW55PiA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGVhZGVyOiB0dXBsZUNWKHtcbiAgICAgICAgICAgIHZlcnNpb246IGJ1ZmZlckNWKHJldmVyc2VCdWZmZXIoQnVmZmVyLmZyb20odmVyc2lvbkhleCwgJ2hleCcpKSksXG4gICAgICAgICAgICBwYXJlbnQ6IGJ1ZmZlckNWKHJldmVyc2VCdWZmZXIoQnVmZmVyLmZyb20ocHJldmlvdXNibG9ja2hhc2gsICdoZXgnKSkpLFxuICAgICAgICAgICAgJ21lcmtsZS1yb290JzogYnVmZmVyQ1YocmV2ZXJzZUJ1ZmZlcihCdWZmZXIuZnJvbShtZXJrbGVyb290LCAnaGV4JykpKSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogYnVmZmVyQ1YobnVtYmVyVG9CdWZmZXIodGltZSwgNCkpLFxuICAgICAgICAgICAgbmJpdHM6IGJ1ZmZlckNWKHJldmVyc2VCdWZmZXIoQnVmZmVyLmZyb20oYml0cywgJ2hleCcpKSksXG4gICAgICAgICAgICBub25jZTogYnVmZmVyQ1YobnVtYmVyVG9CdWZmZXIobm9uY2UsIDQpKSxcbiAgICAgICAgICAgIGhlaWdodDogdWludENWKHN0eEJsb2NrSGVpZ2h0KVxuICAgICAgICB9KSxcbiAgICAgICAgdHg6IGJ1ZmZlckNWKHR4KSxcbiAgICAgICAgcHJvb2Y6IHR1cGxlQ1Yoe1xuICAgICAgICAgICAgXCJ0eC1pbmRleFwiOiB1aW50Q1YodHhJbmRleCksXG4gICAgICAgICAgICBoYXNoZXM6IGxpc3RDVjxCdWZmZXJDVj4ocHJvb2YubWFwKHAgPT4gYnVmZmVyQ1YocmV2ZXJzZUJ1ZmZlcihwKSkpKSxcbiAgICAgICAgICAgIFwidHJlZS1kZXB0aFwiOiB1aW50Q1YocHJvb2YubGVuZ3RoKVxuICAgICAgICB9KSxcbiAgICB9XG59XG5cbmNvbnN0IHByb29mUHJvbWlzZSA9IGdldFR4UHJvb2YodHhpZClcblxucHJvb2ZQcm9taXNlXG4gICAgLnRoZW4odG9Db21wYWN0UHJvb2ZDVilcbiAgICAudGhlbigoe2NvbXBhY3RIZWFkZXIsIHR4LCBwcm9vZn0pID0+IHZlcmlmeUNvbXBhY3RUeChjb21wYWN0SGVhZGVyLCB0eCwgcHJvb2YpKVxuICAgIC50aGVuKHJlc3VsdCA9PiBjdlRvVmFsdWUocmVzdWx0KT8udmFsdWUpXG4gICAgLnRoZW4ociA9PiBjb25zb2xlLmxvZygndmVyaWZ5Q29tcGFjdFR4IHJlc3VsdDonLHIpKVxuICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgdGhyb3cgZVxuICAgIH0pXG5cbnByb29mUHJvbWlzZVxuICAgIC50aGVuKHRvUHJvb2ZDVilcbiAgICAudGhlbigoe2hlYWRlcn0pID0+IGNvbmNhdEhlYWRlcihoZWFkZXIpKVxuICAgIC50aGVuKHJlc3VsdCA9PlxuICAgICAgICBnZXRDVlR5cGVTdHJpbmcocmVzdWx0KSA9PT0gJyhidWZmIDgwKScgPyBjdlRvQnVmZmVyKHJlc3VsdCBhcyBCdWZmZXJDVikudG9TdHJpbmcoJ2hleCcpIDogcmVzdWx0XG4gICAgKVxuICAgIC50aGVuKGNvbnNvbGUubG9nKVxuICAgIC5jYXRjaChjb25zb2xlLmVycm9yKVxuXG5wcm9vZlByb21pc2VcbiAgICAudGhlbih0b1Byb29mQ1YpXG4gICAgLnRoZW4oYXN5bmMgKHtoZWFkZXIsIHR4LCBwcm9vZn0pID0+IHZlcmlmeVR4KGhlYWRlciwgdHgsIHByb29mKSlcbiAgICAudGhlbihyZXN1bHQgPT4gY3ZUb1ZhbHVlKHJlc3VsdCk/LnZhbHVlKVxuICAgIC50aGVuKHIgPT4gY29uc29sZS5sb2coJ3ZlcmlmeVR4IFJlc3VsdDonLCByKSlcbiAgICAuY2F0Y2goZSA9PiBjb25zb2xlLmVycm9yKGUpKVxuIl19
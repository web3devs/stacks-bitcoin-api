import { getBlockStats, getRawBlockHeader, getTransactionDetails } from "./BitcoinRpcClient.js"; // TODO Why is the .js extension required?
import 'dotenv/config';
import { MerkleTree } from "merkletreejs";
import SHA256 from "crypto-js/sha256.js";
import { getStxBlockHeight } from "./BlockApiClient.js";
import { hexOrBufferToBuffer, hexOrBufferToHex, numberToBuffer, reverseBuffer } from "./utils.js";
import { verifyCompactTx, verifyTx } from "./ClarityBitcoinClient.js";
import { bufferCV, listCV, tupleCV, uintCV } from "@stacks/transactions";
const { CLARITY_BITCOIN_CONTRACT_NAME, CLARITY_BITCOIN_CONTRACT_ADDRESS, NETWORK, SENDER_ADDRESS } = process.env;
// const txid = "4a992428186ef340c1137509c484f55793afe6a091dc1ae40169794a4b68a52c"
const txid = "20f85e35d02e28ac89db8764e280db560de1baaa3ce66f15dcea349fb137879c";
// const txid = "4204768f4e125d97d36cf7769adea9140fa28e359ad4d9757e8d8f86cd152050"
const getTxProof = async (txId) => {
    // TODO Make this work for segwit txs
    // TODO add handling of unknown transaction errors
    const txIdHex = hexOrBufferToHex(txId);
    const txDetail = await getTransactionDetails(txIdHex);
    const blockHeader = Buffer.from(await getRawBlockHeader(txDetail.blockhash), 'hex');
    console.log(blockHeader.toString('hex'));
    const blockDetail = await getBlockStats(txDetail.blockhash);
    const stxBlockHeight = await getStxBlockHeight(blockDetail.height);
    const txIndex = blockDetail.tx.findIndex((id) => id === txId);
    const tree = new MerkleTree(blockDetail.tx, SHA256, { isBitcoinTree: true });
    const proof = tree.getProof(blockDetail.tx, txIndex).map(p => p.data);
    // console.log(blockDetail)
    return {
        tx: Buffer.from(txDetail.hex, "hex"),
        txId: hexOrBufferToBuffer(txId),
        txIndex,
        stxBlockHeight,
        blockHeader,
        proof,
        txDetail,
        blockDetail
    };
};
export const toCompactProofCV = async ({ tx, txIndex, proof, blockHeader, stxBlockHeight }) => {
    return {
        compactHeader: tupleCV({
            header: bufferCV(blockHeader),
            height: uintCV(stxBlockHeight)
        }),
        tx: bufferCV(tx),
        proof: tupleCV({
            "tx-index": uintCV(txIndex),
            hashes: listCV(proof.map(p => bufferCV(reverseBuffer(p)))),
            "tree-depth": uintCV(proof.length)
        }),
    };
};
export const toProofCV = async ({ tx, txIndex, proof, stxBlockHeight, blockDetail: { versionHex, previousblockhash, merkleroot, time, bits, nonce } }) => {
    return {
        header: tupleCV({
            version: bufferCV(Buffer.from(versionHex, 'hex')),
            parent: bufferCV(Buffer.from(previousblockhash, 'hex')),
            'merkle-root': bufferCV(Buffer.from(merkleroot, 'hex')),
            timestamp: bufferCV(numberToBuffer(time, 4)),
            nbits: bufferCV(Buffer.from(bits, 'hex')),
            nonce: bufferCV(numberToBuffer(nonce, 4)),
            height: uintCV(stxBlockHeight)
        }),
        tx: bufferCV(tx),
        proof: tupleCV({
            "tx-index": uintCV(txIndex),
            hashes: listCV(proof.map(p => bufferCV(reverseBuffer(p)))),
            "tree-depth": uintCV(proof.length)
        }),
    };
};
const proofPromise = getTxProof(txid);
proofPromise
    .then(toCompactProofCV)
    .then(async ({ compactHeader, tx, proof }) => {
    const result = await verifyCompactTx(compactHeader, tx, proof);
    return result.value;
})
    .then(console.log)
    .catch(e => {
    throw e;
});
proofPromise
    .then(toProofCV)
    .then(async ({ header, tx, proof }) => {
    const result = await verifyTx(header, tx, proof);
    return result;
})
    .then(e => console.log(e))
    .catch(e => console.error('bar:', e)); // TODO Fixme
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsYUFBYSxFQUFFLGlCQUFpQixFQUFFLHFCQUFxQixFQUFDLE1BQU0sdUJBQXVCLENBQUEsQ0FBQywwQ0FBMEM7QUFDeEksT0FBTyxlQUFlLENBQUE7QUFDdEIsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLGNBQWMsQ0FBQTtBQUN2QyxPQUFPLE1BQU0sTUFBTSxxQkFBcUIsQ0FBQTtBQUN4QyxPQUFPLEVBQUMsaUJBQWlCLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQTtBQUdyRCxPQUFPLEVBQUMsbUJBQW1CLEVBQUUsZ0JBQWdCLEVBQUUsY0FBYyxFQUFFLGFBQWEsRUFBQyxNQUFNLFlBQVksQ0FBQztBQUNoRyxPQUFPLEVBQUMsZUFBZSxFQUFFLFFBQVEsRUFBQyxNQUFNLDJCQUEyQixDQUFDO0FBQ3BFLE9BQU8sRUFBVyxRQUFRLEVBQWEsTUFBTSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQUc1RixNQUFNLEVBQ0YsNkJBQTZCLEVBQzdCLGdDQUFnQyxFQUNoQyxPQUFPLEVBQ1AsY0FBYyxFQUNqQixHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUE7QUFhZixrRkFBa0Y7QUFDbEYsTUFBTSxJQUFJLEdBQUcsa0VBQWtFLENBQUE7QUFDL0Usa0ZBQWtGO0FBRWxGLE1BQU0sVUFBVSxHQUFHLEtBQUssRUFBRSxJQUFxQixFQUF1QixFQUFFO0lBQ3BFLHFDQUFxQztJQUNyQyxrREFBa0Q7SUFDbEQsTUFBTSxPQUFPLEdBQUcsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUE7SUFDdEMsTUFBTSxRQUFRLEdBQUcsTUFBTSxxQkFBcUIsQ0FBQyxPQUFPLENBQUMsQ0FBQTtJQUNyRCxNQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0saUJBQWlCLENBQUMsUUFBUSxDQUFD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RUFBRSxLQUFLLEVBQUMsRUFBZ0IsRUFBRTtJQUM5QyxNQUFNLE1BQU0sR0FBRyxNQUFNLFFBQVEsQ0FBQyxNQUFNLEVBQUUsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFBO0lBQ2hELE9BQU8sTUFBTSxDQUFBO0FBQ2pCLENBQUMsQ0FBQztLQUNELElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDekIsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQSxDQUFDLGFBQWEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2dldEJsb2NrU3RhdHMsIGdldFJhd0Jsb2NrSGVhZGVyLCBnZXRUcmFuc2FjdGlvbkRldGFpbHN9IGZyb20gXCIuL0JpdGNvaW5ScGNDbGllbnQuanNcIiAvLyBUT0RPIFdoeSBpcyB0aGUgLmpzIGV4dGVuc2lvbiByZXF1aXJlZD9cbmltcG9ydCAnZG90ZW52L2NvbmZpZydcbmltcG9ydCB7TWVya2xlVHJlZX0gZnJvbSBcIm1lcmtsZXRyZWVqc1wiXG5pbXBvcnQgU0hBMjU2IGZyb20gXCJjcnlwdG8tanMvc2hhMjU2LmpzXCJcbmltcG9ydCB7Z2V0U3R4QmxvY2tIZWlnaHR9IGZyb20gXCIuL0Jsb2NrQXBpQ2xpZW50LmpzXCJcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnQmlnTnVtYmVyLmpzJ1xuaW1wb3J0IEJOIGZyb20gXCJibi5qc1wiO1xuaW1wb3J0IHtoZXhPckJ1ZmZlclRvQnVmZmVyLCBoZXhPckJ1ZmZlclRvSGV4LCBudW1iZXJUb0J1ZmZlciwgcmV2ZXJzZUJ1ZmZlcn0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmltcG9ydCB7dmVyaWZ5Q29tcGFjdFR4LCB2ZXJpZnlUeH0gZnJvbSBcIi4vQ2xhcml0eUJpdGNvaW5DbGllbnQuanNcIjtcbmltcG9ydCB7QnVmZmVyQ1YsIGJ1ZmZlckNWLCBjdlRvVmFsdWUsIGxpc3RDViwgdHVwbGVDViwgdWludENWfSBmcm9tIFwiQHN0YWNrcy90cmFuc2FjdGlvbnNcIjtcbmltcG9ydCB7Q2xhcml0eVZhbHVlfSBmcm9tIFwiQHN0YWNrcy90cmFuc2FjdGlvbnMvZGlzdC9jbGFyaXR5XCI7XG5cbmNvbnN0IHtcbiAgICBDTEFSSVRZX0JJVENPSU5fQ09OVFJBQ1RfTkFNRSxcbiAgICBDTEFSSVRZX0JJVENPSU5fQ09OVFJBQ1RfQUREUkVTUyxcbiAgICBORVRXT1JLLFxuICAgIFNFTkRFUl9BRERSRVNTXG59ID0gcHJvY2Vzcy5lbnZcblxuaW50ZXJmYWNlIFByb3ZhYmxlVHgge1xuICAgIHR4OiBCdWZmZXIsXG4gICAgdHhJZDogQnVmZmVyLFxuICAgIHR4SW5kZXg6IG51bWJlcixcbiAgICBzdHhCbG9ja0hlaWdodDogbnVtYmVyLFxuICAgIGJsb2NrSGVhZGVyOiBCdWZmZXIsXG4gICAgcHJvb2Y6IEJ1ZmZlcltdLFxuICAgIHR4RGV0YWlsOiBhbnksXG4gICAgYmxvY2tEZXRhaWw6IGFueSxcbn1cblxuLy8gY29uc3QgdHhpZCA9IFwiNGE5OTI0MjgxODZlZjM0MGMxMTM3NTA5YzQ4NGY1NTc5M2FmZTZhMDkxZGMxYWU0MDE2OTc5NGE0YjY4YTUyY1wiXG5jb25zdCB0eGlkID0gXCIyMGY4NWUzNWQwMmUyOGFjODlkYjg3NjRlMjgwZGI1NjBkZTFiYWFhM2NlNjZmMTVkY2VhMzQ5ZmIxMzc4NzljXCJcbi8vIGNvbnN0IHR4aWQgPSBcIjQyMDQ3NjhmNGUxMjVkOTdkMzZjZjc3NjlhZGVhOTE0MGZhMjhlMzU5YWQ0ZDk3NTdlOGQ4Zjg2Y2QxNTIwNTBcIlxuXG5jb25zdCBnZXRUeFByb29mID0gYXN5bmMgKHR4SWQ6IHN0cmluZyB8IEJ1ZmZlcik6IFByb21pc2U8UHJvdmFibGVUeD4gPT4ge1xuICAgIC8vIFRPRE8gTWFrZSB0aGlzIHdvcmsgZm9yIHNlZ3dpdCB0eHNcbiAgICAvLyBUT0RPIGFkZCBoYW5kbGluZyBvZiB1bmtub3duIHRyYW5zYWN0aW9uIGVycm9yc1xuICAgIGNvbnN0IHR4SWRIZXggPSBoZXhPckJ1ZmZlclRvSGV4KHR4SWQpXG4gICAgY29uc3QgdHhEZXRhaWwgPSBhd2FpdCBnZXRUcmFuc2FjdGlvbkRldGFpbHModHhJZEhleClcbiAgICBjb25zdCBibG9ja0hlYWRlciA9IEJ1ZmZlci5mcm9tKGF3YWl0IGdldFJhd0Jsb2NrSGVhZGVyKHR4RGV0YWlsLmJsb2NraGFzaCksICdoZXgnKVxuICAgIGNvbnNvbGUubG9nKGJsb2NrSGVhZGVyLnRvU3RyaW5nKCdoZXgnKSlcbiAgICBjb25zdCBibG9ja0RldGFpbCA9IGF3YWl0IGdldEJsb2NrU3RhdHModHhEZXRhaWwuYmxvY2toYXNoKVxuICAgIGNvbnN0IHN0eEJsb2NrSGVpZ2h0ID0gYXdhaXQgZ2V0U3R4QmxvY2tIZWlnaHQoYmxvY2tEZXRhaWwuaGVpZ2h0KSBhcyBudW1iZXJcbiAgICBjb25zdCB0eEluZGV4ID0gYmxvY2tEZXRhaWwudHguZmluZEluZGV4KChpZDogc3RyaW5nKSA9PiBpZCA9PT0gdHhJZClcbiAgICBjb25zdCB0cmVlID0gbmV3IE1lcmtsZVRyZWUoYmxvY2tEZXRhaWwudHgsIFNIQTI1Niwge2lzQml0Y29pblRyZWU6IHRydWV9KVxuICAgIGNvbnN0IHByb29mID0gdHJlZS5nZXRQcm9vZihibG9ja0RldGFpbC50eCwgdHhJbmRleCkubWFwKHAgPT4gcC5kYXRhKVxuXG4gICAgLy8gY29uc29sZS5sb2coYmxvY2tEZXRhaWwpXG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eDogQnVmZmVyLmZyb20odHhEZXRhaWwuaGV4LCBcImhleFwiKSxcbiAgICAgICAgdHhJZDogaGV4T3JCdWZmZXJUb0J1ZmZlcih0eElkKSxcbiAgICAgICAgdHhJbmRleCxcbiAgICAgICAgc3R4QmxvY2tIZWlnaHQsXG4gICAgICAgIGJsb2NrSGVhZGVyLFxuICAgICAgICBwcm9vZixcbiAgICAgICAgdHhEZXRhaWwsXG4gICAgICAgIGJsb2NrRGV0YWlsXG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgdG9Db21wYWN0UHJvb2ZDViA9IGFzeW5jICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHhJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9vZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja0hlYWRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHhCbG9ja0hlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTogUHJvdmFibGVUeCk6IFByb21pc2U8YW55PiA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29tcGFjdEhlYWRlcjogdHVwbGVDVih7XG4gICAgICAgICAgICBoZWFkZXI6IGJ1ZmZlckNWKGJsb2NrSGVhZGVyKSxcbiAgICAgICAgICAgIGhlaWdodDogdWludENWKHN0eEJsb2NrSGVpZ2h0KVxuICAgICAgICB9KSxcbiAgICAgICAgdHg6IGJ1ZmZlckNWKHR4KSxcbiAgICAgICAgcHJvb2Y6IHR1cGxlQ1Yoe1xuICAgICAgICAgICAgXCJ0eC1pbmRleFwiOiB1aW50Q1YodHhJbmRleCksXG4gICAgICAgICAgICBoYXNoZXM6IGxpc3RDVjxCdWZmZXJDVj4ocHJvb2YubWFwKHAgPT4gYnVmZmVyQ1YocmV2ZXJzZUJ1ZmZlcihwKSkpKSxcbiAgICAgICAgICAgIFwidHJlZS1kZXB0aFwiOiB1aW50Q1YocHJvb2YubGVuZ3RoKVxuICAgICAgICB9KSxcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCB0b1Byb29mQ1YgPSBhc3luYyAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvb2YsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R4QmxvY2tIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tEZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbkhleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNibG9ja2hhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lcmtsZXJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTogUHJvdmFibGVUeCk6IFByb21pc2U8YW55PiA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGVhZGVyOiB0dXBsZUNWKHtcbiAgICAgICAgICAgIHZlcnNpb246IGJ1ZmZlckNWKEJ1ZmZlci5mcm9tKHZlcnNpb25IZXgsICdoZXgnKSksXG4gICAgICAgICAgICBwYXJlbnQ6IGJ1ZmZlckNWKEJ1ZmZlci5mcm9tKHByZXZpb3VzYmxvY2toYXNoLCAnaGV4JykpLFxuICAgICAgICAgICAgJ21lcmtsZS1yb290JzogYnVmZmVyQ1YoQnVmZmVyLmZyb20obWVya2xlcm9vdCwgJ2hleCcpKSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogYnVmZmVyQ1YobnVtYmVyVG9CdWZmZXIodGltZSwgNCkpLFxuICAgICAgICAgICAgbmJpdHM6IGJ1ZmZlckNWKEJ1ZmZlci5mcm9tKGJpdHMsICdoZXgnKSksXG4gICAgICAgICAgICBub25jZTogYnVmZmVyQ1YobnVtYmVyVG9CdWZmZXIobm9uY2UsIDQpKSxcbiAgICAgICAgICAgIGhlaWdodDogdWludENWKHN0eEJsb2NrSGVpZ2h0KVxuICAgICAgICB9KSxcbiAgICAgICAgdHg6IGJ1ZmZlckNWKHR4KSxcbiAgICAgICAgcHJvb2Y6IHR1cGxlQ1Yoe1xuICAgICAgICAgICAgXCJ0eC1pbmRleFwiOiB1aW50Q1YodHhJbmRleCksXG4gICAgICAgICAgICBoYXNoZXM6IGxpc3RDVjxCdWZmZXJDVj4ocHJvb2YubWFwKHAgPT4gYnVmZmVyQ1YocmV2ZXJzZUJ1ZmZlcihwKSkpKSxcbiAgICAgICAgICAgIFwidHJlZS1kZXB0aFwiOiB1aW50Q1YocHJvb2YubGVuZ3RoKVxuICAgICAgICB9KSxcbiAgICB9XG59XG5cbmNvbnN0IHByb29mUHJvbWlzZSA9IGdldFR4UHJvb2YodHhpZClcblxucHJvb2ZQcm9taXNlXG4gICAgLnRoZW4odG9Db21wYWN0UHJvb2ZDVilcbiAgICAudGhlbihhc3luYyAoe2NvbXBhY3RIZWFkZXIsIHR4LCBwcm9vZn0pOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmVyaWZ5Q29tcGFjdFR4KGNvbXBhY3RIZWFkZXIsIHR4LCBwcm9vZilcbiAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZVxuICAgIH0pXG4gICAgLnRoZW4oY29uc29sZS5sb2cpXG4gICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICB0aHJvdyBlXG4gICAgfSlcblxucHJvb2ZQcm9taXNlXG4gICAgLnRoZW4odG9Qcm9vZkNWKVxuICAgIC50aGVuKGFzeW5jICh7aGVhZGVyLCB0eCwgcHJvb2Z9KTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmVyaWZ5VHgoaGVhZGVyLCB0eCwgcHJvb2YpXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9KVxuICAgIC50aGVuKGUgPT4gY29uc29sZS5sb2coZSkpXG4gICAgLmNhdGNoKGUgPT4gY29uc29sZS5lcnJvcignYmFyOicsIGUpKSAvLyBUT0RPIEZpeG1lXG4iXX0=
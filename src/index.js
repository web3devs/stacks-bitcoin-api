import { getBlock, getBlockHeader, getRawTransaction } from "./rpcclient.js"; // TODO Why is the .js extension required?
import { bufferCV, callReadOnlyFunction, cvToValue, listCV, tupleCV, uintCV, } from "@stacks/transactions";
import 'dotenv/config';
import { MerkleTree } from "merkletreejs";
import SHA256 from "crypto-js/sha256.js";
import { getStxBlockHeight } from "./BlockApiClient.js";
import { getReversedTxId } from "./ClarityBitcoinClient";
const { CLARITY_BITCOIN_CONTRACT_NAME, CLARITY_BITCOIN_CONTRACT_ADDRESS, NETWORK, SENDER_ADDRESS } = process.env;
const txid = "20f85e35d02e28ac89db8764e280db560de1baaa3ce66f15dcea349fb137879c";
const reverseBuffer = (buffer) => {
    for (let i = 0, j = buffer.length - 1; i < j; ++i, --j) {
        [buffer[i], buffer[j]] = [buffer[j], buffer[i]];
    }
    return buffer;
};
console.assert(reverseBuffer(Buffer.from('00010203', 'hex'))
    .equals(Buffer.from('03020100', 'hex')), 'Reverse buffer failed');
const getTxProof = async (txId) => {
    // TODO Make this work for segwit txs
    // console.log(await getRawTransaction(txid, true))
    const { blockhash, hex } = await getRawTransaction(txid, true);
    const tx = Buffer.from(hex, 'hex');
    // console.log(tx.length)
    const blockHeader = Buffer.from(await getBlockHeader(blockhash), 'hex');
    // console.log(reverseBuffer(blockHeader.subarray(36, 68)).toString('hex'))
    const { tx: txIds, height } = await getBlock(blockhash, 1);
    const stxBlockHeight = await getStxBlockHeight(height);
    const txIndex = txIds.findIndex((id) => id === txId);
    const tree = new MerkleTree(txIds, SHA256, { isBitcoinTree: true });
    // console.log(tree.toString())
    const treeDepth = tree.getDepth();
    const proof = tree.getProof(txId, txIndex).map(p => p.data);
    console.assert(proof.length === treeDepth, "treeDepth and proof don't match");
    return { tx, txId, txIndex, stxBlockHeight, blockHeader, proof };
};
const getBlockHeaderHash = async (blockHeight) => {
    // (get-bc-h-hash (bh uint))
    const functionName = 'get-bc-h-hash';
    const functionArgs = [
        uintCV(58225)
    ];
    const result = await callReadOnlyFunction({
        contractName: CLARITY_BITCOIN_CONTRACT_NAME,
        contractAddress: CLARITY_BITCOIN_CONTRACT_ADDRESS,
        functionName,
        functionArgs,
        network: NETWORK,
        senderAddress: SENDER_ADDRESS,
    });
    return cvToValue(result);
};
const verifyProofOnStacks = async ({ stxBlockHeight, blockHeader, tx, txIndex, proof }) => {
    console.assert(blockHeader.length === 80, "header length incorrect");
    console.assert(tx.length <= 1024, "tx too long");
    // console.log(proof.map(p => p.toString('hex')))
    // console.log(txIndex)
    const functionName = 'was-tx-mined-compact';
    const functionArgs = [
        tupleCV({
            header: bufferCV(blockHeader),
            height: uintCV(stxBlockHeight),
        }),
        bufferCV(tx),
        tupleCV({
            "tx-index": uintCV(txIndex),
            hashes: listCV(proof.map(hash => bufferCV(reverseBuffer(hash)))),
            "tree-depth": uintCV(proof.length)
        })
    ];
    const result = await callReadOnlyFunction({
        contractName: CLARITY_BITCOIN_CONTRACT_NAME,
        contractAddress: CLARITY_BITCOIN_CONTRACT_ADDRESS,
        functionName,
        functionArgs,
        network: NETWORK,
        senderAddress: SENDER_ADDRESS,
    });
    return cvToValue(result).value;
};
getTxProof(txid)
    // .then(getBlockHeaderHash)
    // .then(({blockHeader, stxBlockHeight}: ProvableTx): Promise<boolean> =>
    //     verifyBlockHeader(blockHeader, stxBlockHeight))
    // .then(verifyProofOnStacks)
    .then(async ({ tx, txId }) => {
    const result = await getReversedTxId(tx);
    console.assert(reverseBuffer(Buffer.from(txId, 'hex')).equals(result), txId);
    return result;
})
    .then(console.log)
    .catch(console.error);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsUUFBUSxFQUFFLGNBQWMsRUFBRSxpQkFBaUIsRUFBQyxNQUFNLGdCQUFnQixDQUFBLENBQUMsMENBQTBDO0FBQ3JILE9BQU8sRUFFSCxRQUFRLEVBQ1Isb0JBQW9CLEVBRXBCLFNBQVMsRUFDVCxNQUFNLEVBQ04sT0FBTyxFQUNQLE1BQU0sR0FDVCxNQUFNLHNCQUFzQixDQUFBO0FBQzdCLE9BQU8sZUFBZSxDQUFBO0FBQ3RCLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxjQUFjLENBQUE7QUFDdkMsT0FBTyxNQUFNLE1BQU0scUJBQXFCLENBQUE7QUFDeEMsT0FBTyxFQUFDLGlCQUFpQixFQUFDLE1BQU0scUJBQXFCLENBQUE7QUFDckQsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLHdCQUF3QixDQUFDO0FBRXZELE1BQU0sRUFDRiw2QkFBNkIsRUFDN0IsZ0NBQWdDLEVBQ2hDLE9BQU8sRUFDUCxjQUFjLEVBQ2pCLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQTtBQVdmLE1BQU0sSUFBSSxHQUFHLGtFQUFrRSxDQUFBO0FBRS9FLE1BQU0sYUFBYSxHQUFHLENBQUMsTUFBYyxFQUFVLEVBQUU7SUFDN0MsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUU7UUFDcEQsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7S0FDbEQ7SUFDRCxPQUFPLE1BQU0sQ0FBQTtBQUNqQixDQUFDLENB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QUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUE7SUFDNUUsT0FBTyxNQUFNLENBQUE7QUFDakIsQ0FBQyxDQUFDO0tBQ0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUM7S0FDakIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Z2V0QmxvY2ssIGdldEJsb2NrSGVhZGVyLCBnZXRSYXdUcmFuc2FjdGlvbn0gZnJvbSBcIi4vcnBjY2xpZW50LmpzXCIgLy8gVE9ETyBXaHkgaXMgdGhlIC5qcyBleHRlbnNpb24gcmVxdWlyZWQ/XG5pbXBvcnQge1xuICAgIEJ1ZmZlckNWLFxuICAgIGJ1ZmZlckNWLFxuICAgIGNhbGxSZWFkT25seUZ1bmN0aW9uLFxuICAgIENsYXJpdHlWYWx1ZSxcbiAgICBjdlRvVmFsdWUsXG4gICAgbGlzdENWLFxuICAgIHR1cGxlQ1YsXG4gICAgdWludENWLFxufSBmcm9tIFwiQHN0YWNrcy90cmFuc2FjdGlvbnNcIlxuaW1wb3J0ICdkb3RlbnYvY29uZmlnJ1xuaW1wb3J0IHtNZXJrbGVUcmVlfSBmcm9tIFwibWVya2xldHJlZWpzXCJcbmltcG9ydCBTSEEyNTYgZnJvbSBcImNyeXB0by1qcy9zaGEyNTYuanNcIlxuaW1wb3J0IHtnZXRTdHhCbG9ja0hlaWdodH0gZnJvbSBcIi4vQmxvY2tBcGlDbGllbnQuanNcIlxuaW1wb3J0IHtnZXRSZXZlcnNlZFR4SWR9IGZyb20gXCIuL0NsYXJpdHlCaXRjb2luQ2xpZW50XCI7XG5cbmNvbnN0IHtcbiAgICBDTEFSSVRZX0JJVENPSU5fQ09OVFJBQ1RfTkFNRSxcbiAgICBDTEFSSVRZX0JJVENPSU5fQ09OVFJBQ1RfQUREUkVTUyxcbiAgICBORVRXT1JLLFxuICAgIFNFTkRFUl9BRERSRVNTXG59ID0gcHJvY2Vzcy5lbnZcblxuaW50ZXJmYWNlIFByb3ZhYmxlVHgge1xuICAgIHR4OiBCdWZmZXIsXG4gICAgdHhJZDogc3RyaW5nLFxuICAgIHR4SW5kZXg6IG51bWJlcixcbiAgICBzdHhCbG9ja0hlaWdodDogbnVtYmVyLFxuICAgIGJsb2NrSGVhZGVyOiBCdWZmZXIsXG4gICAgcHJvb2Y6IEJ1ZmZlcltdLFxufVxuXG5jb25zdCB0eGlkID0gXCIyMGY4NWUzNWQwMmUyOGFjODlkYjg3NjRlMjgwZGI1NjBkZTFiYWFhM2NlNjZmMTVkY2VhMzQ5ZmIxMzc4NzljXCJcblxuY29uc3QgcmV2ZXJzZUJ1ZmZlciA9IChidWZmZXI6IEJ1ZmZlcik6IEJ1ZmZlciA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSBidWZmZXIubGVuZ3RoIC0gMTsgaSA8IGo7ICsraSwgLS1qKSB7XG4gICAgICAgIFtidWZmZXJbaV0sIGJ1ZmZlcltqXV0gPSBbYnVmZmVyW2pdLCBidWZmZXJbaV1dXG4gICAgfVxuICAgIHJldHVybiBidWZmZXJcbn1cblxuY29uc29sZS5hc3NlcnQoXG4gICAgcmV2ZXJzZUJ1ZmZlcihCdWZmZXIuZnJvbSgnMDAwMTAyMDMnLCAnaGV4JykpXG4gICAgICAgIC5lcXVhbHMoQnVmZmVyLmZyb20oJzAzMDIwMTAwJywgJ2hleCcpKSxcbiAgICAnUmV2ZXJzZSBidWZmZXIgZmFpbGVkJ1xuKVxuXG5jb25zdCBnZXRUeFByb29mID0gYXN5bmMgKHR4SWQ6IHN0cmluZyk6IFByb21pc2U8UHJvdmFibGVUeD4gPT4ge1xuICAgIC8vIFRPRE8gTWFrZSB0aGlzIHdvcmsgZm9yIHNlZ3dpdCB0eHNcbiAgICAvLyBjb25zb2xlLmxvZyhhd2FpdCBnZXRSYXdUcmFuc2FjdGlvbih0eGlkLCB0cnVlKSlcbiAgICBjb25zdCB7IGJsb2NraGFzaCwgaGV4IH0gPSBhd2FpdCBnZXRSYXdUcmFuc2FjdGlvbih0eGlkLCB0cnVlKVxuICAgIGNvbnN0IHR4ID0gQnVmZmVyLmZyb20oaGV4LCAnaGV4JylcbiAgICAvLyBjb25zb2xlLmxvZyh0eC5sZW5ndGgpXG4gICAgY29uc3QgYmxvY2tIZWFkZXIgPSBCdWZmZXIuZnJvbShhd2FpdCBnZXRCbG9ja0hlYWRlcihibG9ja2hhc2gpLCAnaGV4JylcbiAgICAvLyBjb25zb2xlLmxvZyhyZXZlcnNlQnVmZmVyKGJsb2NrSGVhZGVyLnN1YmFycmF5KDM2LCA2OCkpLnRvU3RyaW5nKCdoZXgnKSlcbiAgICBjb25zdCB7IHR4OiB0eElkcywgaGVpZ2h0IH0gPSBhd2FpdCBnZXRCbG9jayhibG9ja2hhc2gsIDEpXG4gICAgY29uc3Qgc3R4QmxvY2tIZWlnaHQgPSBhd2FpdCBnZXRTdHhCbG9ja0hlaWdodChoZWlnaHQpIGFzIG51bWJlclxuICAgIGNvbnN0IHR4SW5kZXggPSB0eElkcy5maW5kSW5kZXgoKGlkOiBzdHJpbmcpID0+IGlkID09PSB0eElkKTtcbiAgICBjb25zdCB0cmVlID0gbmV3IE1lcmtsZVRyZWUodHhJZHMsIFNIQTI1NiwgeyBpc0JpdGNvaW5UcmVlOiB0cnVlIH0pO1xuICAgIC8vIGNvbnNvbGUubG9nKHRyZWUudG9TdHJpbmcoKSlcbiAgICBjb25zdCB0cmVlRGVwdGggPSB0cmVlLmdldERlcHRoKCk7XG4gICAgY29uc3QgcHJvb2YgPSB0cmVlLmdldFByb29mKHR4SWQsIHR4SW5kZXgpLm1hcChwID0+IHAuZGF0YSk7XG5cbiAgICBjb25zb2xlLmFzc2VydChwcm9vZi5sZW5ndGggPT09IHRyZWVEZXB0aCwgXCJ0cmVlRGVwdGggYW5kIHByb29mIGRvbid0IG1hdGNoXCIpXG5cbiAgICByZXR1cm4geyB0eCwgdHhJZCwgdHhJbmRleCwgc3R4QmxvY2tIZWlnaHQsIGJsb2NrSGVhZGVyLCBwcm9vZiB9XG59XG5cblxuY29uc3QgZ2V0QmxvY2tIZWFkZXJIYXNoID0gYXN5bmMgKGJsb2NrSGVpZ2h0OiBudW1iZXIpOiBQcm9taXNlPGFueT4gPT4ge1xuICAgIC8vIChnZXQtYmMtaC1oYXNoIChiaCB1aW50KSlcbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSAnZ2V0LWJjLWgtaGFzaCdcbiAgICBjb25zdCBmdW5jdGlvbkFyZ3M6IENsYXJpdHlWYWx1ZVtdID0gW1xuICAgICAgICB1aW50Q1YoNTgyMjUpXG4gICAgXVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FsbFJlYWRPbmx5RnVuY3Rpb24oe1xuICAgICAgICBjb250cmFjdE5hbWU6IENMQVJJVFlfQklUQ09JTl9DT05UUkFDVF9OQU1FIGFzIHN0cmluZyxcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiBDTEFSSVRZX0JJVENPSU5fQ09OVFJBQ1RfQUREUkVTUyBhcyBzdHJpbmcsXG4gICAgICAgIGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgZnVuY3Rpb25BcmdzLFxuICAgICAgICBuZXR3b3JrOiBORVRXT1JLIGFzIGFueSxcbiAgICAgICAgc2VuZGVyQWRkcmVzczogU0VOREVSX0FERFJFU1MgYXMgc3RyaW5nLFxuICAgIH0pXG4gICAgcmV0dXJuIGN2VG9WYWx1ZShyZXN1bHQpXG5cbn1cblxuY29uc3QgdmVyaWZ5UHJvb2ZPblN0YWNrcyA9IGFzeW5jICh7IHN0eEJsb2NrSGVpZ2h0LCBibG9ja0hlYWRlciwgdHgsIHR4SW5kZXgsIHByb29mIH06IFByb3ZhYmxlVHgpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICBjb25zb2xlLmFzc2VydChibG9ja0hlYWRlci5sZW5ndGggPT09IDgwLCBcImhlYWRlciBsZW5ndGggaW5jb3JyZWN0XCIpXG4gICAgY29uc29sZS5hc3NlcnQodHgubGVuZ3RoIDw9IDEwMjQsIFwidHggdG9vIGxvbmdcIilcbiAgICAvLyBjb25zb2xlLmxvZyhwcm9vZi5tYXAocCA9PiBwLnRvU3RyaW5nKCdoZXgnKSkpXG4gICAgLy8gY29uc29sZS5sb2codHhJbmRleClcblxuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9ICd3YXMtdHgtbWluZWQtY29tcGFjdCdcbiAgICBjb25zdCBmdW5jdGlvbkFyZ3M6IENsYXJpdHlWYWx1ZVtdID0gW1xuICAgICAgICB0dXBsZUNWKHtcbiAgICAgICAgICAgIGhlYWRlcjogYnVmZmVyQ1YoYmxvY2tIZWFkZXIpLFxuICAgICAgICAgICAgaGVpZ2h0OiB1aW50Q1Yoc3R4QmxvY2tIZWlnaHQpLFxuICAgICAgICB9KSxcbiAgICAgICAgYnVmZmVyQ1YodHgpLFxuICAgICAgICB0dXBsZUNWKHtcbiAgICAgICAgICAgIFwidHgtaW5kZXhcIjogdWludENWKHR4SW5kZXgpLFxuICAgICAgICAgICAgaGFzaGVzOiBsaXN0Q1Y8QnVmZmVyQ1Y+KHByb29mLm1hcChoYXNoID0+IGJ1ZmZlckNWKHJldmVyc2VCdWZmZXIoaGFzaCkpKSksXG4gICAgICAgICAgICBcInRyZWUtZGVwdGhcIjogdWludENWKHByb29mLmxlbmd0aClcbiAgICAgICAgfSlcbiAgICBdXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FsbFJlYWRPbmx5RnVuY3Rpb24oe1xuICAgICAgICBjb250cmFjdE5hbWU6IENMQVJJVFlfQklUQ09JTl9DT05UUkFDVF9OQU1FIGFzIHN0cmluZyxcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiBDTEFSSVRZX0JJVENPSU5fQ09OVFJBQ1RfQUREUkVTUyBhcyBzdHJpbmcsXG4gICAgICAgIGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgZnVuY3Rpb25BcmdzLFxuICAgICAgICBuZXR3b3JrOiBORVRXT1JLIGFzIGFueSxcbiAgICAgICAgc2VuZGVyQWRkcmVzczogU0VOREVSX0FERFJFU1MgYXMgc3RyaW5nLFxuICAgIH0pXG4gICAgcmV0dXJuIGN2VG9WYWx1ZShyZXN1bHQpLnZhbHVlXG59XG5cblxuXG5nZXRUeFByb29mKHR4aWQpXG4gICAgLy8gLnRoZW4oZ2V0QmxvY2tIZWFkZXJIYXNoKVxuICAgIC8vIC50aGVuKCh7YmxvY2tIZWFkZXIsIHN0eEJsb2NrSGVpZ2h0fTogUHJvdmFibGVUeCk6IFByb21pc2U8Ym9vbGVhbj4gPT5cbiAgICAvLyAgICAgdmVyaWZ5QmxvY2tIZWFkZXIoYmxvY2tIZWFkZXIsIHN0eEJsb2NrSGVpZ2h0KSlcbiAgICAvLyAudGhlbih2ZXJpZnlQcm9vZk9uU3RhY2tzKVxuICAgIC50aGVuKGFzeW5jICh7dHgsIHR4SWR9OiBQcm92YWJsZVR4KTogUHJvbWlzZTxCdWZmZXI+ID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0UmV2ZXJzZWRUeElkKHR4KVxuICAgICAgICBjb25zb2xlLmFzc2VydChyZXZlcnNlQnVmZmVyKEJ1ZmZlci5mcm9tKHR4SWQsICdoZXgnKSkuZXF1YWxzKHJlc3VsdCksIHR4SWQpXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9KVxuICAgIC50aGVuKGNvbnNvbGUubG9nKVxuICAgIC5jYXRjaChjb25zb2xlLmVycm9yKSJdfQ==